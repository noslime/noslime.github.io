<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>keepalived&#39;s log</title>
      <link href="articles/2020/3601090912.html"/>
      <url>articles/2020/3601090912.html</url>
      
        <content type="html"><![CDATA[<p>上次搭建nginx集群，并没有处理keepalived的日志，而keepalived的配置文件默认输出到系统日志<code>/var/log/message</code>中，比较混乱。今天实现日志文件自定义输出位置，以便查看。</p><hr><p><strong>1.修改/etc/sysconfig/keepalived</strong></p><p>将<code>KEEPALIVED_OPTIONS=&quot;-D&quot; </code>修改为<code>KEEPALIVED_OPTIONS=&quot;-D -S 0&quot;</code></p><pre class=" language-text"><code class="language-text"># Options for keepalived. See `keepalived --help' output and keepalived(8) and# keepalived.conf(5) man pages for a list of all options. Here are the most# common ones :## --vrrp               -P    Only run with VRRP subsystem.# --check              -C    Only run with Health-checker subsystem.# --dont-release-vrrp  -V    Dont remove VRRP VIPs & VROUTEs on daemon stop.# --dont-release-ipvs  -I    Dont remove IPVS topology on daemon stop.# --dump-conf          -d    Dump the configuration data.# --log-detail         -D    Detailed log messages.# --log-facility       -S    0-7 Set local syslog facility (default=LOG_DAEMON)## KEEPALIVED_OPTIONS="-D"KEEPALIVED_OPTIONS="-D -S 0"~                                </code></pre><p><strong>2.在/etc/rsyslog.conf里添加</strong></p><pre class=" language-text"><code class="language-text">local0.*  /var/log/keepalived.log </code></pre><p><strong>3.重新启动keepalived和rsyslog服务</strong> </p><pre class=" language-shell"><code class="language-shell">systemctl restart rsyslogsystemctl restart keepalived</code></pre><p><strong>4.查看日志信息</strong></p><pre class=" language-shell"><code class="language-shell">tail -f -n 150 /var/log/keepalived.log</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KEEPALIVED </tag>
            
            <tag> LOG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx cluster</title>
      <link href="articles/2020/3501060812.html"/>
      <url>articles/2020/3501060812.html</url>
      
        <content type="html"><![CDATA[<p>nginx虽然实现了应用服务器的负载均衡，但其本身也有down掉的风险，所以为了避免nginx作为分发器时发生单点故障，搭建nginx的集群是有必要的。目前，搭建nginx集群主流方案，是由高可用监控软件Keepalived实现的，本文记录一次搭建过程。</p><h1 id="Nginx-Cluster"><a href="#Nginx-Cluster" class="headerlink" title="Nginx Cluster"></a>Nginx Cluster</h1><h2 id="一、主备模式"><a href="#一、主备模式" class="headerlink" title="一、主备模式"></a>一、主备模式</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>使用两台服务器，一台主服务器和一台热备服务器，当主服务器发生故障时，热备服务器接管主服务器的公网虚拟IP，提供负载均衡服务。主备模式对外提供一个VIP。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><h4 id="安装keepalived软件"><a href="#安装keepalived软件" class="headerlink" title="安装keepalived软件"></a>安装keepalived软件</h4><h5 id="安装指令"><a href="#安装指令" class="headerlink" title="安装指令"></a>安装指令</h5><pre class=" language-shell"><code class="language-shell">yum install keepalived -y</code></pre><h5 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h5><pre class=" language-shell"><code class="language-shell">systemctl start keepalivedsystemctl stop keepalivedsystemctl restart keepalivedsystemctl status keepalived</code></pre><h4 id="修改keepalived配置文件"><a href="#修改keepalived配置文件" class="headerlink" title="修改keepalived配置文件"></a>修改keepalived配置文件</h4><h5 id="master机器"><a href="#master机器" class="headerlink" title="master机器"></a>master机器</h5><pre class=" language-text"><code class="language-text">! Configuration File for keepalivedglobal_defs &#123;   notification_email &#123;     nickname@qq.com   &#125;   notification_email_from nickname@qq.com   smtp_server 127.0.0.1   smtp_connect_timeout 30   router_id vrrp020   script_user root   enable_script_security &#125;vrrp_script check_nginx &#123;    script "/etc/keepalived/nginx_check.sh"    interval 3    weight -20    fall 2    rise 1&#125;vrrp_instance nginx &#123;    state MASTER    interface ens33    mcast_src_ip 192.168.0.20    virtual_router_id 66    priority 100    advert_int 1    authentication &#123;        auth_type PASS        auth_pass 1111    &#125;    virtual_ipaddress &#123;        192.168.0.251    &#125;    track_script &#123;        check_nginx    &#125;&#125;</code></pre><h5 id="backup机器"><a href="#backup机器" class="headerlink" title="backup机器"></a>backup机器</h5><pre class=" language-text"><code class="language-text">! Configuration File for keepalivedglobal_defs &#123;   notification_email &#123;     nickname@qq.com   &#125;   notification_email_from nickname@qq.com   smtp_server 127.0.0.1   smtp_connect_timeout 30   router_id vrrp022   script_user root   enable_script_security&#125;vrrp_script check_nginx &#123;    script "/etc/keepalived/nginx_check.sh"    interval 3    weight -20    fall 2    rise 1&#125;vrrp_instance nginx &#123;    state BACKUP    interface ens33    mcast_src_ip 192.168.0.22    virtual_router_id 66    priority 80    advert_int 1    authentication &#123;        auth_type PASS        auth_pass 1111    &#125;    virtual_ipaddress &#123;        192.168.0.251    &#125;    track_script &#123;        check_nginx    &#125;&#125;</code></pre><h4 id="编写检查脚本"><a href="#编写检查脚本" class="headerlink" title="编写检查脚本"></a>编写检查脚本</h4><p>此脚本的作用是配合keepalived监控nginx的状态，提供唤醒功能，并在nginx无法唤醒的情况下，结束故障服务器的keepalived进程，以实现VIP漂移。</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>counter<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">ps</span> -C nginx --no-heading<span class="token operator">|</span><span class="token function">wc</span> -l<span class="token variable">)</span></span><span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$counter</span>"</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"$&amp;#123;counter&amp;#125;"</span> <span class="token operator">=</span> <span class="token string">"0"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    nginx -c /usr/local/nginx/conf/nginx.conf    <span class="token function">sleep</span> 2    counter<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">ps</span> -C nginx --no-heading<span class="token operator">|</span><span class="token function">wc</span> -l<span class="token variable">)</span></span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"$&amp;#123;counter&amp;#125;"</span> <span class="token operator">=</span> <span class="token string">"0"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        systemctl stop keepalived    <span class="token keyword">fi</span><span class="token keyword">fi</span></code></pre><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><p>分别在主机和从机上启动nginx与keepalived。</p><pre class=" language-shell"><code class="language-shell">nginx -c /usr/local/nginx/conf/nginx.confsystemctl start keepalived</code></pre><h4 id="测试服务"><a href="#测试服务" class="headerlink" title="测试服务"></a>测试服务</h4><p>若顺利启动主备模式后则可以通过访问虚拟IP的地址得到想要的结果</p><pre class=" language-shell"><code class="language-shell">curl -i 192.168.0.251   #返回为nginx代理的服务即可</code></pre><p>手动关闭主机nginx后，可以很快重新恢复服务</p><pre class=" language-shell"><code class="language-shell">nginx -s stopps aux | grep nginx  #一两秒后nginx进程自动恢复则正常</code></pre><p>手动关闭主机keepalived后，短暂延时后可以正常访问nginx代理的服务</p><pre class=" language-shell"><code class="language-shell">systemctl stop keepalivedcurl -i 192.168.0.251    #短暂延时后，可以正常根据VIP访问</code></pre><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p><strong>第一次启动失败</strong></p><p>通过<code>sytemctl status keepalived</code>查看状态发现状态为<strong>dead</strong>，核心提示如下</p><pre class=" language-text"><code class="language-text">Keepalived_vrrp exited with permanent error CONFIG. Terminating</code></pre><p>提示出现永久的配置出错，一时也发现不了错误，配置文件也没动过，所以第一时间去看日志。keepalived的日志文件默认在<code>/var/log/message</code>中，通过日志文件，得到线索如下</p><pre><code>keepalived.service: Can&#39;t open PID file /var/run/keepalived.pid (yet?) after start: No such file or directory</code></pre><p>上述日志提示进程ID文件不存在，手动创建即可。</p><pre class=" language-text"><code class="language-text">WARNING - interface eth0 for vrrp_instance VI_1 doesn't existNon-existent interface specified in configuration</code></pre><p>上述日志提示配置文件中网卡 <strong>eht0</strong> 不存在，通过<code>ip addr</code>命令发现，虚拟机中的网卡名为<strong>ens33</strong>。修改keepalived配置文件，将网卡名称替换为实际存在的即可。其中keepalived的配置文件的默认位置为<code>/etc/keepalived/keepalived.conf</code></p><hr><p><strong>第二次启动失败</strong></p><p>将日志提示的错误修改完成后重新启动keepalived发现，还是启不来，并提示使用<code>journalctl -Ex</code>命令查看系统日志</p><p>系统日志如下</p><pre class=" language-text"><code class="language-text">SELinux is preventing keepalived from read access on the file keepalived.pid. For complete SELinux messages run: seal>SELinux is preventing keepalived from read access on the file keepalived.pid.</code></pre><p>提示安全系统<strong>SELinux</strong> 阻止读取进程ID文件，此时可以根据提示生成本地策略以允许此访问</p><pre class=" language-shell"><code class="language-shell"># ausearch -c 'keepalived' --raw | audit2allow -M my-keepalived# semodule -X 300 -i my-keepalived.pp</code></pre><p>或者也可以关闭SELinux的Enforcing模式，开启宽容模式</p><pre class=" language-shell"><code class="language-shell"># setenforce 0</code></pre><hr><p><strong>主机与从机均绑定了VIP</strong></p><ol><li><p>首先执行命令<code> tcpdump -i ens33 vrrp -n</code>查看下网卡<code>ens33</code>上的组播报文</p><p><img src="https://cdn.jsdelivr.net/gh/noslime/noslime.github.io@master/source/images/tcpdumvrrp.png"></p><p>可见，主机20和备机22都在发送组播报文</p></li><li><p>主从模式中，备机收到报文后是不会再发的，可见备机没有收到组播消息。初步判断防火墙问题。</p></li><li><p>首先直接关闭防火墙，以<em>centos7</em>为例，</p><pre class=" language-shell"><code class="language-shell"># systemctl stop firewalld </code></pre><p>可见关闭后只有主机在发报文</p><p><img src="https://cdn.jsdelivr.net/gh/noslime/noslime.github.io@master/source/images/tcpdumpvrrp2.png"></p></li><li><p>通过<code>ip add</code> 发现只有主机绑定了 <em>192.168.0.251</em>这个虚拟IP，符合了我们的预期</p><p>主机部分</p><p><img src="https://cdn.jsdelivr.net/gh/noslime/noslime.github.io@master/source/images/keepalivevip2.png"></p><p>备机部分</p><p><img src="https://cdn.jsdelivr.net/gh/noslime/noslime.github.io@master/source/images/keepalivevip1.png"></p></li><li><p>更优雅一点，通过防火墙开启vrrp组播通信的权限，而不是直接关闭防火墙，命令如下</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 0 --in-interface ens33 --destination 224.0.0.18 --protocol vrrp -j ACCEPT</span><span class="token comment" spellcheck="true"># firewall-cmd --reload</span></code></pre><p>其中<strong>224.0.0.18</strong> 是vrrp组播通信的默认广播地址。</p><hr></li></ol><h2 id="二、双主模式"><a href="#二、双主模式" class="headerlink" title="二、双主模式"></a>二、双主模式</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>主从模式中，一台做主，一台做备。虽然一定程度上实现了高可用，但备机大多数情况下处于浪费状态。为了解决备机的浪费问题，可以让两台机器互为主备，即每一台机器既担当主机的角色，又拥有备机的身份，这就是双主模式。双主模式对外提供两个VIP。</p><h3 id="实现过程-1"><a href="#实现过程-1" class="headerlink" title="实现过程"></a>实现过程</h3><p>双主模式只要在<em>keepalived</em>的配置文件中配置两个实例即可，在主备模式的基础上，只需要以下两步：</p><p>1、在主机配置文件中增加备机实例</p><pre class=" language-text"><code class="language-text">vrrp_instance nginx02 &#123;    state BACKUP    interface ens33    mcast_src_ip 192.168.0.20    virtual_router_id 68    priority 80    advert_int 1    authentication &#123;        auth_type PASS        auth_pass 1111    &#125;    virtual_ipaddress &#123;        192.168.0.252    &#125;    track_script &#123;        check_nginx    &#125;&#125;</code></pre><p>2、在备机配置文件中增加主机实例</p><pre class=" language-text"><code class="language-text">vrrp_instance nginx02 &#123;    state MASTER    interface ens33    mcast_src_ip 192.168.0.22    virtual_router_id 68    priority 100    advert_int 1    authentication &#123;        auth_type PASS        auth_pass 1111    &#125;    virtual_ipaddress &#123;        192.168.0.252    &#125;    track_script &#123;        check_nginx    &#125;&#125;</code></pre><blockquote><p>其中，同原实例相比，需要修改的部分有：</p><p>实例名称：vrrp_instance</p><p>实例初始状态：state</p><p>节点优先级：priority</p><p>虚拟IP地址：virtual_ipaddress</p><p>虚拟路由ID：virtual_router_id  相同vrid的为一组</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NGINX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown表格中代码块竖线问题</title>
      <link href="articles/2020/0220080712.html"/>
      <url>articles/2020/0220080712.html</url>
      
        <content type="html"><![CDATA[<p>当我们编写markdown格式的文档，不可避免的会用到表格，有时候我们会在表格中用到 <code>|</code> 符号，由于这个符号属于markdown表格定义符号，所以不可避免会遇到一些显示问题。当我用typora编写markdown文件通过hexo生成网页时，由于在表格里写了代码块，恰好发生了格式显示错误，本文记录解决过程。</p><h2 id="一、首行代码块中存在竖线"><a href="#一、首行代码块中存在竖线" class="headerlink" title="一、首行代码块中存在竖线"></a>一、首行代码块中存在竖线</h2><h3 id="问题表现"><a href="#问题表现" class="headerlink" title="问题表现"></a>问题表现</h3><h4 id="Tpory编辑器显示："><a href="#Tpory编辑器显示：" class="headerlink" title="Tpory编辑器显示："></a>Tpory编辑器显示：</h4><p><img src="https://cdn.jsdelivr.net/gh/noslime/noslime.github.io@master/source/images/vertical_line02.png"></p><h4 id="Hexo网页显示"><a href="#Hexo网页显示" class="headerlink" title="Hexo网页显示"></a>Hexo网页显示</h4><p><img src="https://cdn.jsdelivr.net/gh/noslime/noslime.github.io@master/source/images/vertical_line03.png"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>首先查看markdown源码</p><p><img src="https://cdn.jsdelivr.net/gh/noslime/noslime.github.io@master/source/images/vertical_line01.png"></p><p>通过源码可知，markdown编辑器默认帮我们给非代码部分的 <code>|</code>字符添加了转义字符 <code>\</code>  ，所以可以手动给代码块部分添加</p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>通过标签插件提供的 {%raw%} {%endraw%} 标签包裹不需要解析的位置。</p><h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p>直接使用HTML标签&lt;code&gt;替代反引号包裹含有竖线的代码块</p><h2 id="二、非首行代码块中存在竖线"><a href="#二、非首行代码块中存在竖线" class="headerlink" title="二、非首行代码块中存在竖线"></a>二、非首行代码块中存在竖线</h2><h3 id="问题表现-1"><a href="#问题表现-1" class="headerlink" title="问题表现"></a>问题表现</h3><h4 id="Tpory编辑器显示：-1"><a href="#Tpory编辑器显示：-1" class="headerlink" title="Tpory编辑器显示："></a>Tpory编辑器显示：</h4><p><img src="https://cdn.jsdelivr.net/gh/noslime/noslime.github.io@master/source/images/vertical_line04.png"></p><h4 id="Hexo网页显示-1"><a href="#Hexo网页显示-1" class="headerlink" title="Hexo网页显示"></a>Hexo网页显示</h4><p><img src="https://cdn.jsdelivr.net/gh/noslime/noslime.github.io@master/source/images/vertical_line05.png"></p><blockquote><p> 虽然导致错误形式不同，但解决方案同问题一，此处不在赘述</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MARKDOWN </tag>
            
            <tag> CASE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGINX限流</title>
      <link href="articles/2020/2206060612.html"/>
      <url>articles/2020/2206060612.html</url>
      
        <content type="html"><![CDATA[<h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><hr><h2 id="一、限流介绍"><a href="#一、限流介绍" class="headerlink" title="一、限流介绍"></a>一、限流介绍</h2><p>限流（rate limiting）是NGINX众多特性中的重要特性之一。该特性可以限制某个用户在一个给定时间段内能够产生的HTTP请求数以及请求的处理速率。用于安全目的上，比如减慢暴力密码破解攻击。通过限制进来的请求速率，并且（结合日志）标记出目标URLs来帮助防范DDoS攻击，保护带宽及服务器的IO资源。一般地说，限流是用在保护上游应用服务器不被在同一时刻的大量用户请求湮没</p><h2 id="二、相关模块"><a href="#二、相关模块" class="headerlink" title="二、相关模块"></a>二、相关模块</h2><h3 id="1-ngx-http-limit-conn-module"><a href="#1-ngx-http-limit-conn-module" class="headerlink" title="1) ngx_http_limit_conn_module"></a>1) ngx_http_limit_conn_module</h3><p>此模块用于限制每个定义的键的连接数，特别是来自单个IP地址的连接数。 不是所有的连接都被计算在内。 只有当一个连接被服务器处理并且整个请求头已经被读取时，它才会被计数。用来限制同一时间连接数，即并发限制。</p><p><strong>配置示例</strong></p><pre><code>http &#123;    limit_conn_zone $binary_remote_addr zone=addr:10m;    ...    server &#123;        ...        location /download/ &#123;            limit_conn addr 1;&#125;</code></pre><p><strong>相关指令</strong></p><table><thead><tr><th align="left">Syntax:</th><th><code>limit_conn zone number;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><p>设置共享内存区域和给定键值的最大允许连接数。 当超过此限制时，服务器将返回定义的错误界面。 例如</p><pre><code>limit_conn_zone $binary_remote_addr zone=addr:10m;server &#123;    location /download/ &#123;        limit_conn addr 1;&#125;</code></pre><p>每个IP每次只允许一个连接，在HTTP/2和SPDY中，每个并发请求都被认为是一个单独的连接。</p><p>可以有多个limit_conn指令。例如，以下配置将限制每个客户端IP与服务器的连接数量，同时限制与虚拟服务器的连接总数：</p><pre><code>limit_conn_zone $binary_remote_addr zone=perip:10m;limit_conn_zone $server_name zone=perserver:10m;server &#123;    ...    limit_conn perip 10;    limit_conn perserver 100;&#125;</code></pre><table><thead><tr><th align="left">Syntax:</th><th><code>limit_conn_dry_run on | off;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td><code>limit_conn_dry_run off;</code></td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><p>启用干运行模式（ 1.17.6）。 在这种模式下，连接的数量不受限制，但在共享内存区域中，过度连接的数量照常计算。</p><table><thead><tr><th>Syntax:</th><th><code>limit_conn_log_level info | notice | warn | error;</code></th></tr></thead><tbody><tr><td>Default:</td><td><code>limit_conn_log_level error;</code></td></tr><tr><td>Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><p>设置服务器限制连接数量的情况下所需的日志记录级别（0.8.18）。</p><table><thead><tr><th align="left">Syntax:</th><th><code>limit_conn_status code;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td><code>limit_conn_status 503;</code></td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><p>设置要返回的状态代码以响应被拒绝的请求(1.3.15)。</p><table><thead><tr><th align="left">Syntax:</th><th><code>limit_conn_zone key zone=name:size;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td><code>http</code></td></tr></tbody></table><p>设置共享内存区域的参数，该区域将保留各种键的状态。 其中，状态包括当前连接数。 键可以包含文本，变量及其组合。 不计算带空键值的请求。在版本1.7.6之前，一个键只能包含一个变量。</p><p>使用示例</p><pre><code>limit_conn_zone $binary_remote_addr zone=addr:10m;</code></pre><p>其中内置参数<code>$binary_remote_addr</code>为客户端的IP地址，与 <code>$remote_addr</code>相比，前者为定长，后者不定长。addr 为共享内存区域的名字，10m为大小。</p><h3 id="2-ngx-http-limit-req-module"><a href="#2-ngx-http-limit-req-module" class="headerlink" title="2)   ngx_http_limit_req_module"></a>2)   ngx_http_limit_req_module</h3><p>此模块（0.7.21）用于限制每个定义的键的请求处理速率，特别是来自单个IP地址的请求的处理速率。 限制是使用“漏桶”算法（缓存请求、匀速处理、多余的请求直接丢弃）完成的。单位时间的请求数，速率限制。</p><p><strong>配置示例</strong></p><pre><code>http &#123;    limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;    ...    server &#123;        ...        location /search/ &#123;            limit_req zone=one burst=5; &#125;</code></pre><p><strong>相关指令</strong></p><table><thead><tr><th align="left">Syntax:</th><th><code>limit_req zone=name [burst=number] [nodelay | delay=number];</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><p>共享内存区的大小和请求的最大值。如果请求速率超过为区域配置的速率，则它们的处理将被延迟，以便以定义的速率处理请求。过多的请求会被延迟，直到它们的数量超过最大突发大小，在这种情况下，请求会因错误而终止。默认情况下，最大突发大小等于零。</p><pre><code>limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;server &#123;    location /search/ &#123;        limit_req zone=one burst=5;&#125;</code></pre><p>上述配置表示平均每秒允许不超过1个请求，突发请求不超过5个。burst这个配置的意思是设置一个大小为5的缓冲区当有大量请求（爆发）过来时，超过了访问频次限制的请求可以先放到这个缓冲区内。</p><p>延迟参数（1.15.7）指定了过度请求被延迟的限制。 默认值为零，即所有超速的请求都被延迟了</p><p>如果不希望在请求受到限制时延迟过多的请求，则应该使用参数nodelay：</p><pre><code>limit_req zone=one burst=5 nodelay;</code></pre><p>如果设置，超过访问频次而且缓冲区也满了的时候就会直接返回错误503，如果没有设置，则所有请求会等待排队。</p><p>可以配置多个limit_req指令。 例如，以下配置将限制来自单个IP地址的请求的处理速率，同时限制虚拟服务器的请求处理速率：</p><pre><code>limit_req_zone $binary_remote_addr zone=perip:10m rate=1r/s;limit_req_zone $server_name zone=perserver:10m rate=10r/s;server &#123;    ...    limit_req zone=perip burst=5 nodelay;    limit_req zone=perserver burst=10;&#125;</code></pre><table><thead><tr><th align="left">Syntax:</th><th><code>limit_req_dry_run on | off;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td><code>limit_req_dry_run off;</code></td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><p>启用干运行模式（1.17.1）。在这种模式下，请求处理速率不受限制，但是在共享内存区中，过量请求的数量照常计算</p><table><thead><tr><th align="left">Syntax:</th><th><code>limit_req_log_level info | notice | warn | error;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td><code>limit_req_log_level error;</code></td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><p>为服务器因速率超过而拒绝处理请求或延迟请求处理的情况设置所需的日志记录级别（ 0.8.18）。延迟的日志记录级别比拒绝的记录级别低一分；例如，如果指定了“limit_req_log_level notice”，则延迟将用info级别记录。</p><table><thead><tr><th align="left">Syntax:</th><th><code>limit_req_status code;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td><code>limit_req_status 503;</code></td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><p>设置要返回的状态代码以响应被拒绝的请求 (1.3.15)</p><table><thead><tr><th align="left">Syntax:</th><th><code>limit_req_zone key zone=name:size rate=rate [sync];</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td><code>http</code></td></tr></tbody></table><p>为共享内存区域设置参数，该区域将保持各种键的状态。其中，状态存储当前过多请求的数量。键可以包含文本、变量及其组合。不计算键值为空的请求。在版本1.7.6之前，一个键只能包含一个变量。</p><p>指令示例</p><pre><code>limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;</code></pre><p>在这里，状态被保存在一个10兆字节的区域“one”，并且该区域的平均请求处理速率不能超过每秒1个请求</p><p>如果区域存储耗尽，则删除最近使用最少的状态。 如果在此之后无法创建新状态，则请求将以错误终止。</p><p>速率在每秒请求(r/s)中指定)。 如果要求每秒少于一个请求的速率，则在每分钟请求(r/m)中指定)。 例如，每秒半请求为30r/m</p><h2 id="三、其他限制指令"><a href="#三、其他限制指令" class="headerlink" title="三、其他限制指令"></a>三、其他限制指令</h2><h3 id="1-限速"><a href="#1-限速" class="headerlink" title="1)限速"></a>1)限速</h3><table><thead><tr><th align="left">Syntax:</th><th><code>limit_rate rate;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td><code>limit_rate 0;</code></td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code>, <code>if in location</code></td></tr></tbody></table><p>限制对客户端的响应传输速率。 速率以每秒字节为单位指定。 零值禁用速率限制。 限制是根据请求设置的，因此如果客户端同时打开两个连接，则总速率将是指定限制的两倍</p><p>参数值可以包含变量（1.17.0）。在根据特定条件限制速率的情况下，该方法可能有用：</p><pre><code>map $slow $rate &#123;    1     4k;    2     8k;&#125;limit_rate $rate;</code></pre><p>速率限制也可以在$limit_rate变量中设置，但是，由于版本1.17.0，不推荐使用此方法：</p><pre><code>server &#123;    if ($slow) &#123;        set $limit_rate 4k;    &#125;    ...&#125;</code></pre><table><thead><tr><th align="left">Syntax:</th><th><code>limit_rate_after size;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td><code>limit_rate_after 0;</code></td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code>, <code>if in location</code></td></tr></tbody></table><p>设置初始数量，在此之后，对客户端的响应的进一步传输将受到速率限制。参数值可以包含变量（1.17.0）。</p><pre><code>location /flv/ &#123;    flv;    limit_rate_after 500k;    limit_rate       50k;&#125;</code></pre><h3 id="2-限制HTTP方法"><a href="#2-限制HTTP方法" class="headerlink" title="2)限制HTTP方法"></a>2)限制HTTP方法</h3><table><thead><tr><th align="left">Syntax:</th><th><code>limit_except method ... &#123; ... &#125;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td><code>location</code></td></tr></tbody></table><p>限制一个位置内允许的HTTP方法。方法参数可以是以下参数之一：GET、HEAD、POST、PUT、DELETE、MKCOL、COPY、MOVE、OPTIONS、PROPFIND、PROPPATCH、LOCK、UNLOCK或PATCH。允许GET方法使HEAD方法也被允许。可以使用ngx_http_Access_module、ngx_http_auth_basic_module和ngx_http_auth_jwt_module（1.13.10）modules指令来限制对其他方法的访问：</p><pre><code>limit_except GET &#123;    allow 192.168.1.0/32;    deny  all;&#125;</code></pre><p>请注意，这将限制对所有方法的访问，除了GET和HEAD。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NGINX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis datatype and command</title>
      <link href="articles/2020/2314030312.html"/>
      <url>articles/2020/2314030312.html</url>
      
        <content type="html"><![CDATA[<p>因为redis的数据类型大都比较简明易懂，也拥有着极其丰富中英文社区文档，所以仅以此文总结下<strong>常用的数据类型</strong>及其操作命令==简介== ，主要目的为学习一遍数据类型及其相关命令，方便今后自己查阅。若要查阅命令详情，请访问<a href="https://redis.io/commands">redis Commands</a>  或 <a href="http://www.redis.cn/commands.html">redis 中文</a>。</p><blockquote><p>当前redis版本 ==6.2.0==</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>redis的数据类型常见的有字符串（String）、哈希表（Hash）、列表（List）、集合（Set）、有序集合（zset）五种，另外还有位图（bitmaps）、HyperLogLogs、Streams。本文主要记录下前五种数据类型及命令简介。</p><hr><h2 id="Redis-keys"><a href="#Redis-keys" class="headerlink" title="Redis keys"></a>Redis keys</h2><p>redis键是二进制安全的，这意味着可以使用任何二进制序列作为键，比如ipg图片或者序列化的对象， 空字符串也是有效的键。</p><p>键允许的最大值为512M。</p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><table><thead><tr><th align="left">命令</th><th>起始版本</th><th>时间复杂度</th><th>基本语法</th><th align="left">简述</th></tr></thead><tbody><tr><td align="left">TYPE</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>TYPE  key</td><td align="left">用于返回 key 所储存的值的类型。</td></tr><tr><td align="left">PEXPIREAT</td><td><strong>2.6.0</strong></td><td>O(1)</td><td>PEXPIREAT key milliseconds-timestamp</td><td align="left">设置 key 到什么时候过期，以毫秒计。</td></tr><tr><td align="left">RENAME</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>RENAME key newkey</td><td align="left">修改 key 的名称</td></tr><tr><td align="left">PERSIST</td><td><strong>2.2.0</strong></td><td>O(1)</td><td>PERSIST  key</td><td align="left">移除 key 的过期时间，key 将持久保持。</td></tr><tr><td align="left">MOVE</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>MOVE key db</td><td align="left">将当前数据库的 key 移动到给定的数据库 db 当中。</td></tr><tr><td align="left">RANDOMKEY</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>RANDOMKEY</td><td align="left">从当前数据库中随机返回一个 key 。</td></tr><tr><td align="left">DUMP</td><td><strong>2.6.0</strong></td><td>O(1)</td><td>DUMP  key</td><td align="left">序列化给定 key ，并返回被序列化的值。</td></tr><tr><td align="left">TTL</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>TTL  key</td><td align="left">以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</td></tr><tr><td align="left">EXPIRE</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>EXPIRE key seconds</td><td align="left">为给定 key 设置过期时间。</td></tr><tr><td align="left">DEL</td><td><strong>1.0.0</strong></td><td>O(N)</td><td>DEL key [key …]</td><td align="left">该命令用于在 key 存在时删除 key。</td></tr><tr><td align="left">PTTL</td><td><strong>2.6.0</strong></td><td>O(1)</td><td>PTTL key</td><td align="left">以毫秒为单位返回 key 的剩余的过期时间。</td></tr><tr><td align="left">RENAMENX</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>RENAMENX key newkey</td><td align="left">仅当 newkey 不存在时，将 key 改名为 newkey 。</td></tr><tr><td align="left">EXISTS</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>EXISTS key [key …]</td><td align="left">判断当前key是否存在</td></tr><tr><td align="left">EXPIREAT</td><td><strong>1.2.0</strong></td><td>O(1)</td><td>EXPIREAT key timestamp</td><td align="left">EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td></tr><tr><td align="left">KEYS</td><td><strong>1.0.0</strong></td><td>O(N)</td><td>KEYS pattern</td><td align="left">查找所有符合给定模式( pattern)的 key 。</td></tr></tbody></table><hr><h2 id="Redis-Strings"><a href="#Redis-Strings" class="headerlink" title="Redis Strings"></a>Redis Strings</h2><p>字符串是最基本的Redis值。 Redis Strings是二进制安全的，这意味着Redis字符串可以包含任何类型的数据，例如JPEG图像或序列化的JAVA对象。字符串值的长度可以达到最大512兆字节。</p><h3 id="相关命令-1"><a href="#相关命令-1" class="headerlink" title="相关命令"></a>相关命令</h3><table><thead><tr><th align="left">命令</th><th>起始版本</th><th>时间复杂度</th><th>基本语法</th><th align="left">简述</th></tr></thead><tbody><tr><td align="left">SETNX</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>SETNX key value</td><td align="left">只有在 key 不存在时设置 key 的值。</td></tr><tr><td align="left">GETRANGE</td><td><strong>2.4.0</strong></td><td>O(N)</td><td>GETRANGE key start end</td><td align="left">返回 key 中字符串值的子字符 起始0，结束-1</td></tr><tr><td align="left">MSET</td><td><strong>1.0.1</strong></td><td>O(N)</td><td>MSET key value [key value …]</td><td align="left">同时设置一个或多个 key-value 对，是原子操作。</td></tr><tr><td align="left">MSETNX</td><td><strong>1.0.1</strong></td><td>O(N)</td><td>MSETNX key value [key value …]</td><td align="left">同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td></tr><tr><td align="left">SETEX</td><td><strong>2.0.0</strong></td><td>O(1)</td><td>SETEX key seconds value</td><td align="left">将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td></tr><tr><td align="left">PSETEX</td><td><strong>2.6.0</strong></td><td>O(1)</td><td>PSETEX key milliseconds value</td><td align="left">这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间</td></tr><tr><td align="left">SET</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>SET key value [EX seconds|PX milliseconds|KEEPTTL] [NX|XX] [GET]</td><td align="left">设置指定 key 的值<br />&gt;= 2.6.12: Added the EX, PX, NX and XX options.<br/>&gt;= 6.0: Added the KEEPTTL option.<br/>&gt;= 6.2: Added the GET option.</td></tr><tr><td align="left">GET</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>GET key</td><td align="left">获取指定 key 的值。</td></tr><tr><td align="left">GETBIT</td><td><strong>2.2.0</strong></td><td>O(1)</td><td>GETBIT key offset</td><td align="left">对 key 所储存的字符串值，获取指定偏移量上的位(bit)。是二进制位的偏移量。</td></tr><tr><td align="left">SETBIT</td><td><strong>2.2.0</strong></td><td>O(1)</td><td>SETBIT key offset value</td><td align="left">对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。是二进制位的偏移量。</td></tr><tr><td align="left">DECR</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>DECR key</td><td align="left">将 key 中储存的数字值减一。</td></tr><tr><td align="left">DECRBY</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>DECRBY key decrement</td><td align="left">key 所储存的值减去给定的减量值（decrement） 。</td></tr><tr><td align="left">STRLEN</td><td><strong>2.2.0</strong></td><td>O(1)</td><td>STRLEN key</td><td align="left">返回 key 所储存的字符串值的长度。</td></tr><tr><td align="left">INCR</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>INCR key</td><td align="left">将 key 中储存的数字值增一。</td></tr><tr><td align="left">Incrby</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>INCRBY key increment</td><td align="left">将 key 所储存的值加上给定的增量值（increment） 。</td></tr><tr><td align="left">INCRBYFLOAT</td><td><strong>2.6.0</strong></td><td>O(1)</td><td>INCRBYFLOAT key increment</td><td align="left">将 key 所储存的值加上给定的浮点增量值（increment） 。</td></tr><tr><td align="left">SETRANGE</td><td><strong>2.2.0</strong></td><td>O(1)</td><td>SETRANGE key offset value</td><td align="left">用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td></tr><tr><td align="left">APPEND</td><td><strong>2.0.0</strong></td><td>O(1)</td><td>APPEND key value</td><td align="left">如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。</td></tr><tr><td align="left">GETSET</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>GETSET key value</td><td align="left">将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td></tr><tr><td align="left">MGET</td><td><strong>1.0.0</strong></td><td>O(N)</td><td>MGET key [key …]</td><td align="left">获取所有(一个或多个)给定 key 的值。</td></tr></tbody></table><hr><h2 id="Redis-List"><a href="#Redis-List" class="headerlink" title="Redis List"></a>Redis List</h2><p>Redis lists允许重复值，并且基于Linked Lists实现，。这意味着即使在一个list中有数百万个元素，在头部或尾部添加一个元素的操作，其时间复杂度也是常数级别的。LPUSH 命令插入一个新元素到列表头部，而RPUSH命令 插入一个新元素到列表的尾部。当对一个空key执行其中某个命令时，将会创建一个新表。</p><h3 id="相关命令-2"><a href="#相关命令-2" class="headerlink" title="相关命令"></a>相关命令</h3><table><thead><tr><th align="left">命令</th><th>起始版本</th><th>时间复杂度</th><th>基本语法</th><th align="left">简述</th></tr></thead><tbody><tr><td align="left">LPUSH</td><td><strong>1.0.0</strong></td><td>O(1) or O(N)</td><td>LPUSH key element [element …]</td><td align="left">将一个或多个值插入到列表头部</td></tr><tr><td align="left">LPUSHX</td><td><strong>2.2.0</strong></td><td>O(1) or O(N)</td><td>LPUSHX key element [element …]</td><td align="left">将一个或多个值插入到列表头部，当且仅当列表存在时插入</td></tr><tr><td align="left">RPUSH</td><td><strong>1.0.0</strong></td><td>O(1) or O(N)</td><td>RPUSH key element [element …]</td><td align="left">在列表尾部插入所有指定的值。</td></tr><tr><td align="left">RPUSHX</td><td><strong>2.2.0</strong></td><td>O(1) or O(N)</td><td>RPUSHX key element [element …]</td><td align="left">只有当键已经存在并持有列表时，才在存储在键的列表尾部插入指定值</td></tr><tr><td align="left">LPOP</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>LPOP key</td><td align="left">移除并返回存储在列表的第一个元素。</td></tr><tr><td align="left">RPOP</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>RPOP key</td><td align="left">移除并返回存储在列表的最后一个元素</td></tr><tr><td align="left">RPOPLPUSH</td><td><strong>1.2.0</strong></td><td>O(1)</td><td>RPOPLPUSH source destination</td><td align="left">移除列表的最后一个元素，并将该元素添加到另一个列表头部并返回</td></tr><tr><td align="left">LREM</td><td><strong>1.0.0</strong></td><td>O(N+M)</td><td>LREM key count element</td><td align="left">移除列表中指定count数量的与element相同的元素<br /> count=0 移除所有相等元素<br /> count&gt;0 从队首开始移除指定个数<br /> count&lt;0 从队尾开始移除指定个数</td></tr><tr><td align="left">LLEN</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>LLEN key</td><td align="left">返回列表长度</td></tr><tr><td align="left">LINDEX</td><td><strong>1.0.0</strong></td><td>O(N)</td><td>LINDEX key index</td><td align="left">返回指定索引的元素</td></tr><tr><td align="left">LINSERT</td><td><strong>2.2.0</strong></td><td>O(N)</td><td>LINSERT key BEFORE|AFTER pivot element</td><td align="left">在指定元素前后插入元素</td></tr><tr><td align="left">LSET</td><td><strong>1.0.0</strong></td><td>O(N)</td><td>LSET key index element</td><td align="left">设置指定索引处的元素</td></tr><tr><td align="left">LRANGE</td><td><strong>1.0.0</strong></td><td>O(S+N)</td><td>LRANGE key start stop</td><td align="left">获取列表指定范围内的元素</td></tr><tr><td align="left">LTRIM</td><td><strong>1.0.0</strong></td><td>O(N)</td><td>LTRIM key start stop</td><td align="left">截取列表，只保留指定范围内的元素</td></tr><tr><td align="left">LPOS</td><td><strong>6.0.6</strong></td><td>O(N)</td><td>LPOS key element [RANK rank] [COUNT num-matches] [MAXLEN len]</td><td align="left">返回列表中匹配列表的索引，rank指定返回第几个匹配元素的索引，count指定返回几个匹配元素的索引， maxlen指定比较的次数。</td></tr><tr><td align="left">BLPOP</td><td><strong>2.0.0</strong></td><td>O(1)</td><td>BLPOP key [key …] timeout</td><td align="left">该命令返回Redis列表中匹配元素的索引该命令返回Redis列表中匹配元素的索引移除并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left">BRPOP</td><td><strong>2.0.0</strong></td><td>O(1)</td><td>BRPOP key [key …] timeout</td><td align="left">移除并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left">BRPOPLPUSH</td><td><strong>2.2.0</strong></td><td>O(1)</td><td>BRPOPLPUSH source destination timeout</td><td align="left">移除列表的最后一个元素，并将该元素添加到另一个列表头部并返回，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td align="left">LMOVE</td><td><strong>6.2.0</strong></td><td>O(1)</td><td>LMOVE source destination LEFT|RIGHT LEFT|RIGHT</td><td align="left">原子性地返回并移除存储在源中的列表的第一个/最后一个元素，并将元素推送到存储在目标位置的列表的第一个/最后一个元素。<br /> 此命令可以用来代替不太推荐的<code>RPOPLPUSH</code>命令</td></tr><tr><td align="left">BLMOVE</td><td><strong>6.2.0</strong></td><td>O(1)</td><td>BLMOVE source destination LEFT|RIGHT LEFT|RIGHT timeout</td><td align="left">此命令是<code>LMOVE</code>的阻塞变体</td></tr></tbody></table><hr><h2 id="Redis-Hash"><a href="#Redis-Hash" class="headerlink" title="Redis Hash"></a>Redis Hash</h2><p>Redis Hashes是字符串字段和字符串值之间的映射，hash特别适合用于存储对象。类似java里面的Map&lt;String,Object&gt;，每个散列最多可存储(2^32)-1个字段值对（超过40亿）。</p><h3 id="相关命令-3"><a href="#相关命令-3" class="headerlink" title="相关命令"></a>相关命令</h3><table><thead><tr><th align="left">命令</th><th>起始版本</th><th>时间复杂度</th><th>基本语法</th><th align="left">简述</th></tr></thead><tbody><tr><td align="left">HSET</td><td><strong>2.0.0</strong></td><td>O(1) or O(N)</td><td>HSET key field value [field value …]</td><td align="left">设置存储在哈希表中一个或多个字段的值</td></tr><tr><td align="left">HSETNX</td><td><strong>2.0.0</strong></td><td>O(1)</td><td>HSETNX key field value</td><td align="left">设置哈希表中一个字段的值，当且仅当字段不存在时起作用。</td></tr><tr><td align="left"><del>HMSET</del></td><td><strong>2.0.0</strong></td><td>O(N)</td><td>HMSET key field value [field value …]</td><td align="left">4.0.0以后已弃用，作用同<code>HSET</code></td></tr><tr><td align="left">HGET</td><td><strong>2.0.0</strong></td><td>O(1)</td><td>HGET key field</td><td align="left">返回存储在键处的哈希中与字段关联的值</td></tr><tr><td align="left">HGETALL</td><td><strong>2.0.0</strong></td><td>O(N)</td><td>HGETALL key</td><td align="left">返回存储在键处的哈希的所有字段和值。</td></tr><tr><td align="left">HMGET</td><td><strong>2.0.0</strong></td><td>O(N)</td><td>HMGET key field [field …]</td><td align="left">返回存储在哈希中与指定字段关联的一个或多个值。</td></tr><tr><td align="left">HEXISTS</td><td><strong>2.0.0</strong></td><td>O(1)</td><td>HEXISTS key field</td><td align="left">返回字段在哈希中是否存在。1存在 0不存在</td></tr><tr><td align="left">HDEL</td><td><strong>2.0.0</strong></td><td>O(N)</td><td>HDEL key field [field …]</td><td align="left">删除哈希表中指定的字段</td></tr><tr><td align="left">HLEN</td><td><strong>2.0.0</strong></td><td>O(1)</td><td>HLEN key</td><td align="left">返回哈希表中字段的数量</td></tr><tr><td align="left">HSTRLEN</td><td><strong>3.2.0</strong></td><td>O(1)</td><td>HSTRLEN key field</td><td align="left">返回存储在键处的哈希中与字段关联的值的字符串长度。如果键或字段不存在，则返回0。</td></tr><tr><td align="left">HINCRBY</td><td><strong>2.0.0</strong></td><td>O(1)</td><td>HINCRBY key field increment</td><td align="left">为哈希表 key 中的指定字段的整数值加上增量 increment 。返回增长后的值</td></tr><tr><td align="left">HINCRBYFLOAT</td><td><strong>2.6.0</strong></td><td>O(1)</td><td>HINCRBYFLOAT key field increment</td><td align="left">为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td></tr><tr><td align="left">HKEYS</td><td><strong>2.0.0</strong></td><td>O(N)</td><td>HKEYS key</td><td align="left">返回存储在哈希表中所有的字段名称</td></tr><tr><td align="left">HVALS</td><td><strong>2.0.0</strong></td><td>O(N)</td><td>HVALS key</td><td align="left">返回存储在哈希表中所有的字段的值</td></tr><tr><td align="left">HSCAN</td><td><strong>2.8.0</strong></td><td>O(1) or O(N)</td><td>HSCAN key cursor [MATCH pattern] [COUNT count]</td><td align="left">用于迭代哈希中的键值对。数据量较小时count不工作。</td></tr></tbody></table><hr><h2 id="Redis-Set"><a href="#Redis-Set" class="headerlink" title="Redis Set"></a>Redis Set</h2><p>Redis集合是一个无序的字符串合集。它是通过HashTable实现的，你可以以<strong>O(1)</strong> 的时间复杂度完成 添加、删除以及测试元素是否存在的操作。</p><h3 id="相关命令-4"><a href="#相关命令-4" class="headerlink" title="相关命令"></a>相关命令</h3><table><thead><tr><th align="left">命令</th><th>起始版本</th><th>时间复杂度</th><th>基本语法</th><th align="left">简述</th></tr></thead><tbody><tr><td align="left">SADD</td><td><strong>1.0.0</strong></td><td>O(1) or O(N)</td><td>SADD key member [member …]</td><td align="left">向集合中添加一个或多个元素</td></tr><tr><td align="left">SISMEMBER</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>SISMEMBER key member</td><td align="left">判断元素是否是集合的成员</td></tr><tr><td align="left">SPOP</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>SPOP key [count]</td><td align="left">移除并返回集合中的一个或指定数量随机元素</td></tr><tr><td align="left">SRANDMEMBER</td><td><strong>1.0.0</strong></td><td>O(1) or O(N)</td><td>SRANDMEMBER key [count]</td><td align="left">随机访问集合中的一个或指定数量随机元素并返回</td></tr><tr><td align="left">SREM</td><td><strong>1.0.0</strong></td><td>O(N)</td><td>SREM key member [member …]</td><td align="left">移除列出的元素</td></tr><tr><td align="left">SMOVE</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>SMOVE source destination member</td><td align="left">将一个集合中的指定元素移动到另一个集合中去</td></tr><tr><td align="left">SCARD</td><td><strong>1.0.0</strong></td><td>O(1)</td><td>SCARD key</td><td align="left">获取集合的成员数</td></tr><tr><td align="left">SMEMBERS</td><td><strong>1.0.0</strong></td><td>O(N)</td><td>SMEMBERS key</td><td align="left">返回集合中的所有成员</td></tr><tr><td align="left">SSCAN</td><td><strong>2.8.0</strong></td><td>O(1) or O(N)</td><td>SSCAN key cursor [MATCH pattern] [COUNT count]</td><td align="left">迭代集合中的元素</td></tr><tr><td align="left">SINTER</td><td><strong>1.0.0</strong></td><td>O(N*M)</td><td>SINTER key [key …]</td><td align="left">返回给定所有集合的交集</td></tr><tr><td align="left">SINTERSTORE</td><td><strong>1.0.0</strong></td><td>O(N*M)</td><td>SINTERSTORE destination key [key …]</td><td align="left">返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td align="left">SUNION</td><td><strong>1.0.0</strong></td><td>O(N)</td><td>SUNION key [key …]</td><td align="left">返回给定所有集合的并集</td></tr><tr><td align="left">SUNIONSTORE</td><td><strong>1.0.0</strong></td><td>O(N)</td><td>SUNIONSTORE destination key [key …]</td><td align="left">返回给定所有集合的并集并存储在 destination 中</td></tr><tr><td align="left">SDIFF</td><td><strong>1.0.0</strong></td><td>O(N)</td><td>SDIFF key [key …]</td><td align="left">返回给定所有集合的差集，只返回第一个集合的差集</td></tr><tr><td align="left">SDIFFSTORE</td><td><strong>1.0.0</strong></td><td>O(N)</td><td>SDIFFSTORE destination key [key …]</td><td align="left">返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td align="left">SMISMEMBER</td><td><strong>6.2.0</strong></td><td>O(N)</td><td>SMISMEMBER key member [member …]</td><td align="left">返回每个成员是否是存储在集合的成员。 对于每个成员，如果值是集合的成员，则返回1，如果元素不是集合的成员，或者如果键不存在，则返回0。</td></tr></tbody></table><hr><h2 id="Redis-Sorted-sets"><a href="#Redis-Sorted-sets" class="headerlink" title="Redis Sorted sets"></a>Redis Sorted sets</h2><p>类似Sets,但是每个字符串元素都关联到一个叫<em>score</em>浮动数值（floating number value）。里面的元素总是通过score进行着排序，其中zset的成员是唯一的，但分数（score）却可以重复。</p><h3 id="相关命令-5"><a href="#相关命令-5" class="headerlink" title="相关命令"></a>相关命令</h3><table><thead><tr><th align="left">命令</th><th>起始版本</th><th>时间复杂度</th><th>基本语法</th><th align="left">简述</th></tr></thead><tbody><tr><td align="left">ZADD</td><td><strong>1.2.0</strong></td><td>O(log(N))</td><td>ZADD key [NX|XX] [GT|LT] [CH] [INCR] score member [score member …]</td><td align="left">将具有指定分数的所有指定成员添加到存储在键处的有序集中。<br />&gt;=2.4：接受多个元素。在2.4版之前的Redis版本中，每次调用都只能添加或更新一个成员。<br/>&gt;=3.0.2：增加了XX、NX、CH和INCR选项。<br/>&gt;=6.2:添加了GT和LT选项。</td></tr><tr><td align="left">ZSCORE</td><td><strong>1.2.0</strong></td><td>O(1)</td><td>ZSCORE key member</td><td align="left">返回有序集合中单个成员的分数</td></tr><tr><td align="left">ZMSCORE</td><td><strong>6.2.0</strong></td><td>O(N)</td><td>ZMSCORE key member [member …]</td><td align="left">返回有序集合中一个或多个成员的分数</td></tr><tr><td align="left">ZRANK</td><td><strong>2.0.0</strong></td><td>O(log(N))</td><td>ZRANK key member</td><td align="left">返回有序集合中指定成员的索引</td></tr><tr><td align="left">ZINCRBY</td><td><strong>1.2.0</strong></td><td>O(log(N))</td><td>ZINCRBY key increment member</td><td align="left">有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td align="left">ZCARD</td><td><strong>1.2.0</strong></td><td>O(1)</td><td>ZCARD key</td><td align="left">获取有序集合的成员数</td></tr><tr><td align="left">ZCOUNT</td><td><strong>2.0.0</strong></td><td>O(log(N))</td><td>ZCOUNT key min max</td><td align="left">计算在有序集合中指定区间分数的成员数</td></tr><tr><td align="left">ZLEXCOUNT</td><td><strong>2.8.9</strong></td><td>O(log(N))</td><td>ZLEXCOUNT key min max</td><td align="left">在有序集合中计算指定字典区间内成员数量</td></tr><tr><td align="left">ZRANGE</td><td><strong>1.2.0</strong></td><td>O(log(N)+M)</td><td>ZRANGE key start stop [WITHSCORES]</td><td align="left">返回存储在键处的排序集中的指定元素范围。</td></tr><tr><td align="left">ZRANGEBYLEX</td><td><strong>2.8.9</strong></td><td>O(log(N)+M)</td><td>ZRANGEBYLEX key min max [LIMIT offset count]</td><td align="left">ZRANGEBYLEX 返回指定成员区间内的成员，按成员字典正序排序, 分数必须相同。</td></tr><tr><td align="left">ZRANGEBYSCORE</td><td><strong>1.0.5</strong></td><td>O(log(N)+M)</td><td>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</td><td align="left">通过分数返回有序集合指定区间内的成员</td></tr><tr><td align="left">ZREVRANGE</td><td><strong>1.2.0</strong></td><td>O(log(N)+M)</td><td>ZREVRANGE key start stop [WITHSCORES]</td><td align="left">返回有序集中指定区间内的成员，通过索引，分数从高到底</td></tr><tr><td align="left">ZREVRANGEBYLEX</td><td><strong>2.8.9</strong></td><td>O(log(N)+M)</td><td>ZREVRANGEBYLEX key max min [LIMIT offset count]</td><td align="left">ZREVRANGEBYLEX 返回指定成员区间内的成员，按成员字典倒序排序, 分数必须相同。</td></tr><tr><td align="left">ZREVRANGEBYSCORE</td><td><strong>2.2.0</strong></td><td>O(log(N)+M)</td><td>ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</td><td align="left">返回有序集合中指定分数区间内的成员，分数由高到低排序。</td></tr><tr><td align="left">ZREVRANK</td><td><strong>2.0.0</strong></td><td>O(log(N))</td><td>ZREVRANK key member</td><td align="left">返回有序集合中指定成员的索引，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td align="left">ZREM</td><td><strong>1.2.0</strong></td><td>O(M*log(N))</td><td>ZREM key member [member …]</td><td align="left">从存储在键处的有序集中移除指定的成员。</td></tr><tr><td align="left">ZREMRANGEBYSCORE</td><td><strong>1.2.0</strong></td><td>O(log(N)+M)</td><td>ZREMRANGEBYSCORE key min max</td><td align="left">移除有序集合中给定的分数区间的所有成员</td></tr><tr><td align="left">ZREMRANGEBYLEX</td><td><strong>2.8.9</strong></td><td>O(log(N)+M)</td><td>ZREMRANGEBYLEX key min max</td><td align="left">移除有序集合中给定的字典区间的所有成员</td></tr><tr><td align="left">ZREMRANGEBYRANK</td><td><strong>2.0.0</strong></td><td>O(log(N)+M)</td><td>ZREMRANGEBYRANK key start stop</td><td align="left">移除有序集合中给定的索引区间的所有成员</td></tr><tr><td align="left">ZPOPMAX</td><td><strong>5.0.0</strong></td><td>O(log(N)*M)</td><td>ZPOPMAX key [count]</td><td align="left">删除并返回最多count个排序集中得分最高的成员。</td></tr><tr><td align="left">ZPOPMIN</td><td><strong>5.0.0</strong></td><td>O(log(N)*M)</td><td>ZPOPMIN key [count]</td><td align="left">删除并返回最多count个排序集中得分最低的成员。</td></tr><tr><td align="left">BZPOPMAX</td><td><strong>5.0.0</strong></td><td>O(log(N))</td><td>BZPOPMAX key [key …] timeout</td><td align="left"><code>BZPOPMAX</code>是有序集合<code>ZPOPMAX</code>原语的阻塞版本。</td></tr><tr><td align="left">BZPOPMIN</td><td><strong>5.0.0</strong></td><td>O(log(N))</td><td>BZPOPMIN key [key …] timeout</td><td align="left"><code>BZPOPMIN</code>是有序集合<code>ZPOPMIN</code>原语的阻塞版本。</td></tr><tr><td align="left">ZUNION</td><td><strong>6.2.0</strong></td><td>O(N)+O(M*log(M))</td><td>ZUNION numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX] [WITHSCORES]</td><td align="left">计算给定的一个或多个有序集的并集</td></tr><tr><td align="left">ZUNIONSTORE</td><td><strong>2.0.0</strong></td><td>O(N)+O(M log(M))</td><td>ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</td><td align="left">计算给定的一个或多个有序集的并集，并存储在新的有序集合中</td></tr><tr><td align="left">ZINTER</td><td><strong>6.2.0</strong></td><td>O(N<em>K)+O(M</em>log(M))</td><td>ZINTER numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX] [WITHSCORES]</td><td align="left">计算给定的一个或多个有序集的交集</td></tr><tr><td align="left">ZINTERSTORE</td><td><strong>2.0.0</strong></td><td>O(N<em>K)+O(M</em>log(M))</td><td>ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]</td><td align="left">计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合中</td></tr><tr><td align="left">ZDIFF</td><td><strong>6.2.0</strong></td><td>O(L + (N-K)log(N))</td><td>ZDIFF numkeys key [key …] [WITHSCORES]</td><td align="left">计算给定的一个或多个有序集的差集</td></tr><tr><td align="left">ZDIFFSTORE</td><td><strong>6.2.0</strong></td><td>O(L + (N-K)log(N))</td><td>ZDIFFSTORE destination numkeys key [key …]</td><td align="left">计算给定的一个或多个有序集的差集并将结果集存储在新的有序集合中</td></tr><tr><td align="left">ZSCAN</td><td><strong>2.8.0</strong></td><td>O(1) or O(N)</td><td>ZSCAN key cursor [MATCH pattern] [COUNT count]</td><td align="left">迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><hr><h2 id="Redis-Bitmaps"><a href="#Redis-Bitmaps" class="headerlink" title="Redis Bitmaps"></a>Redis Bitmaps</h2><p>位图不是实际的数据类型，而是在字符串类型上定义的一组面向位的操作。由于字符串是二进制安全blob，其最大长度为512MB，因此它们适合设置多达232个不同的位。<br>位操作分为两组：恒定时间的单位操作，如将位设置为1或0，或获取其值，以及对位组的操作，例如在给定的位范围内计算设定位的数量（例如，总体计数）。<br>位图的最大优点之一是，在存储信息时，它们通常可以极大地节省空间。例如，在一个用递增的用户id表示不同用户的系统中，仅使用512MB内存就可以记住40亿用户的一个比特信息（例如，知道用户是否希望接收新闻稿）。</p><h2 id="Redis-HyperLogLogs"><a href="#Redis-HyperLogLogs" class="headerlink" title="Redis HyperLogLogs"></a>Redis HyperLogLogs</h2><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><h2 id="Redis-Streams"><a href="#Redis-Streams" class="headerlink" title="Redis Streams"></a>Redis Streams</h2><p>Stream是Redis 5.0版本引入的一个新的数据类型，它以更抽象的方式模拟<em>日志数据结构</em>，但日志仍然是完整的：就像一个日志文件，通常实现为以只附加模式打开的文件，Redis流主要是一个仅附加数据结构。至少从概念上来讲，因为Redis流是一种在内存表示的抽象数据类型，他们实现了更加强大的操作，以此来克服日志文件本身的限制。</p><p>Stream是Redis的数据类型中最复杂的，尽管数据类型本身非常简单，它实现了额外的非强制性的特性：提供了一组允许消费者以阻塞的方式等待生产者向Stream中发送的新消息，此外还有一个名为<strong>消费者组</strong>的概念。</p><p>消费者组最早是由名为Kafka（TM）的流行消息系统引入的。Redis用完全不同的术语重新实现了一个相似的概念，但目标是相同的：允许一组客户端相互配合来消费同一个Stream的不同部分的消息。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REDIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>REDIS安装</title>
      <link href="articles/2020/2214010312.html"/>
      <url>articles/2020/2214010312.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h1><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><pre class=" language-shell"><code class="language-shell">$ wget https://download.redis.io/releases/redis-6.0.9.tar.gz$ tar xzf redis-6.0.9.tar.gz$ cd redis-6.0.9$ make$ make install </code></pre><p>运行服务端</p><pre class=" language-shell"><code class="language-shell">reids-server  /usr/local/redis/redis.conf</code></pre><p>测试客户端</p><pre class=" language-shell"><code class="language-shell">$ redis-cliredis> pingPONG</code></pre><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><h4 id="未安装GCC"><a href="#未安装GCC" class="headerlink" title="未安装GCC"></a>未安装GCC</h4><pre class=" language-shell"><code class="language-shell"># cc: command not foundsudo yum install gcc</code></pre><h4 id="默认内存分配器错误"><a href="#默认内存分配器错误" class="headerlink" title="默认内存分配器错误"></a>默认内存分配器错误</h4><pre class=" language-shell"><code class="language-shell"># fatal error: jemalloc/jemalloc.h: No such file or directorysudo make MALLOC=libc</code></pre><h4 id="gcc版本过低"><a href="#gcc版本过低" class="headerlink" title="gcc版本过低"></a>gcc版本过低</h4><pre class=" language-shell"><code class="language-shell"># error: expected specifier-qualifier-list before ‘_Atomic’sudo yum install centos-release-sclsudo yum install devtoolset-8-gcc*scl enable devtoolset-8 bash# 然后清理下错误编译make distclean</code></pre><h4 id="无法正常关闭redis服务"><a href="#无法正常关闭redis服务" class="headerlink" title="无法正常关闭redis服务"></a>无法正常关闭redis服务</h4><ul><li>客户端报错</li></ul><blockquote><p>127.0.0.1:6379&gt; SHUTDOWN<br>(error) ERR Errors trying to SHUTDOWN. Check logs.</p></blockquote><ul><li>日志信息</li></ul><blockquote><p>User requested shutdown…<br>Saving the final RDB snapshot before exiting.<br>Failed opening the RDB file dump.rdb (in server root dir /usr/local/redis-6.0.9) for saving: Permission denied<br>Error trying to save the DB, can’t exit.</p></blockquote><ul><li>修改权限信息</li></ul><pre class=" language-shell"><code class="language-shell">sudo chmod 777 dump.rdbsudo chmod 777 /usr/local/redisdir</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REDIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux设置静态IP</title>
      <link href="articles/2020/2219062811.html"/>
      <url>articles/2020/2219062811.html</url>
      
        <content type="html"><![CDATA[<h3 id="CentOS-7-设置静态IP"><a href="#CentOS-7-设置静态IP" class="headerlink" title="CentOS  7  设置静态IP"></a>CentOS  7  设置静态IP</h3><ol><li><p>查看网卡信息</p><p>执行<code>ifconfig</code>命令查看网卡名称</p><p><img src="https://cdn.jsdelivr.net/gh/noslime/noslime.github.io@master/source/images/linuxifconfig.png"></p><p>如图网卡名称为ens33</p><p>在<code>/etc/sysconfig/network-scripts</code> 文件夹下查找ens33对应的配置文件，如在我的系统中为<code>ifcfg-ens33</code> ，首先备份配置文件（若文件不存在，可自行创建一个）</p><pre class=" language-shell"><code class="language-shell">cp /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts/ifcfg-ens33.bakup</code></pre></li><li><p>然后在其中添加以下语句设置静态IP，请勿复制注释信息</p><pre class=" language-shell"><code class="language-shell">DEVICE="ens33"            #描述网卡对应的设备别名BOOTPROTO="static"        #设置网卡获得ip地址的方式，可能的选项为static，默认dhcp动态获取IPADDR="192.168.0.20"       #设置的静态IP地址NETMASK="255.255.255.0"     #子网掩码GATEWAY="192.168.0.1"       #网关地址DNS1="223.5.5.5"           #dns信息DNS2="8.8.8.8"               #dns信息ONBOOT="yes"              # 开机启用</code></pre></li><li><p>重启网络服务</p><pre class=" language-shell"><code class="language-shell">systemctl restart network  //centos 7或nmcli c reload        //centos 8  需重启</code></pre></li></ol><h3 id="Ubuntu-20-04-设置静态IP"><a href="#Ubuntu-20-04-设置静态IP" class="headerlink" title="Ubuntu 20.04 设置静态IP"></a>Ubuntu 20.04 设置静态IP</h3><p>​    ubuntu20版本系统设置静态IP需要修改<code>/etc/netplan</code> 下面的<code>1-network-manager-all.yaml</code>文件</p><ol><li><p>同样执行<code>ifconfig</code>查看当前网卡信息</p><p>网卡依旧是ens33，就不截图了</p></li><li><p>备份原配置文件</p><pre class=" language-shell"><code class="language-shell">sudo cp /etc/netplan/01-network-manager-all.yaml /etc/netplan/01-network-manager-all.yaml.backup</code></pre></li><li><p>修改<code>1-network-manager-all.yaml</code>文件为：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># Let NetworkManager manage all devices on this system</span><span class="token key atrule">network</span><span class="token punctuation">:</span>  <span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">renderer</span><span class="token punctuation">:</span> NetworkManager  <span class="token key atrule">ethernets</span><span class="token punctuation">:</span>      <span class="token key atrule">ens33</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#网卡</span>        <span class="token key atrule">dhcp4</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true">#关闭动态获取ip</span>      <span class="token key atrule">addresses</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>192.168.0.21/24<span class="token punctuation">]</span>   <span class="token comment" spellcheck="true">#IP及掩码长度</span>      <span class="token key atrule">geteway4</span><span class="token punctuation">:</span> 192.168.0.1    <span class="token comment" spellcheck="true">#网关</span>      <span class="token key atrule">nameservers</span><span class="token punctuation">:</span>          <span class="token key atrule">addresses</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>223.5.5.5<span class="token punctuation">,</span> 8.8.8.8<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#DNS</span></code></pre></li><li><p>使更改生效</p><pre class=" language-shell"><code class="language-shell">sudo netplan --debug apply</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CASE </tag>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux创建用户并赋予root权限</title>
      <link href="articles/2020/2209062811.html"/>
      <url>articles/2020/2209062811.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、创建用户"><a href="#一、创建用户" class="headerlink" title="一、创建用户"></a>一、创建用户</h3><p>创建一个带有家目录，并且可以登录bash的用户</p><pre class=" language-shell"><code class="language-shell">su        //切换root用户创建用户useradd -m -s /bin/bash noslime    </code></pre><p>给创建的用户分配密码，并切换到noslime用户</p><pre class=" language-shell"><code class="language-shell">passwd noslimesu - noslime</code></pre><h3 id="二、赋予root权限"><a href="#二、赋予root权限" class="headerlink" title="二、赋予root权限"></a>二、赋予root权限</h3><p>方案一</p><p>修改/etc/sudoers文件，使得用户noslime免密使用sudo命令</p><pre class=" language-shell"><code class="language-shell">echo "nolime ALL=(ALL:ALL)  NOPASSWD:ALL" >> /etc/sudoers</code></pre><p>方案二</p><p>将用户添加到管理员用户组wheel中去，有的linux发行版，需要将<code>/etc/sudoers</code>文件中以下一行的注释打开：</p><pre class=" language-shell"><code class="language-shell">%wheel  ALL=(ALL)       ALL  //centos 7 8 ubuntu20版本默认打开,看一下不费事</code></pre><p>将用户添加到wheel管理员用户组中</p><pre class=" language-shell"><code class="language-shell">usermod -g wheel noslime   //给用户指定主用户组usermod -G wheel noslime   //给用户指定用户组，添加操作，但会去除原有附加组gpasswd -a user_name group_name   //添加用户到组 建议操作gpasswd -d user_name group_name   //将用户从指定组中删除</code></pre><p>修改成功后通过<code>groups username</code> 或 <code>id username</code>查看用户的组是否添加成功，添加成功后如无作用，可<strong>重启系统</strong>使之生效，即可使用sudo命令获得管理员权限。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CASE </tag>
            
            <tag> LINUX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGINX反向代理与负载均衡</title>
      <link href="articles/2020/2217152711.html"/>
      <url>articles/2020/2217152711.html</url>
      
        <content type="html"><![CDATA[<p>nginx的反向代理与负载均衡是我们日常工作中经常用到的功能，并且给我们带来了较大的便利。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>​        反向代理在计算机网络中是代理服务器的一种。服务器根据客户端的请求，从其关系的一组或多组后端服务器上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器集群的存在。</p></blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>1)提高了内部服务器的安全</strong></p><blockquote><p>​        外部网络用户通过反向代理访问内部服务器，只能看到反向代理服务器的IP地址和端口号，内部服务器对于外部网络是完全不可见的。 此外，没有信息资源被保存在反向代理服务器上。 所有网页程序都存储在内部服务器上。 对反向代理服务器的攻击不会破坏真实的网页信息系统，从而提高了内部服务器的安全性。</p></blockquote><p><strong>2)加快了对内部服务器的访问速度</strong></p><blockquote><p>​        反向代理服务器的缓存功能还可以加快用户的访问速度。</p></blockquote><p><strong>3)节约了有限的IP资源</strong></p><blockquote><p>​         公共网络分配的IP地址数量是有限的。 如果为每个服务器分配了一个公共网络地址，则不可能，反向代理技术可以解决IP地址不足的问题。</p></blockquote><p><strong>4)应用场景</strong></p><blockquote><ul><li>堡垒机，保护后端服务器的安全</li><li>将多个服务器通过虚拟主机的方式发布到公网</li><li>缓存服务器，CDN加速</li></ul></blockquote><h3 id="NGINX反向代理"><a href="#NGINX反向代理" class="headerlink" title="NGINX反向代理"></a>NGINX反向代理</h3><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><blockquote><pre><code>server &#123;    listen 80;    server_name localhost;    lacation / &#123;        index index.html index.htm;        proxy_pass  http://target_server:port;  //代理的目标服务器    &#125;&#125;</code></pre></blockquote><h4 id="可配参数"><a href="#可配参数" class="headerlink" title="可配参数"></a>可配参数</h4><blockquote><pre><code>server &#123;listen 80;server_name localhost;    location / &#123;           index index.html index.htm;           proxy_pass  http://target_server:port;  //代理的目标服务器           proxy_set_header Host      $host;       //设置请求主机名           proxy_set_header X-Real-IP $remote_addr;//设置上游访问IP           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for //客户端访问IP           proxy_buffering  on       //默认为on，开启缓冲后端服务器响应           proxy_buffer_size 16k;   //代理服务器保存响应头信息的缓冲区大小，默认情况也为分页大小           proxy_buffers 4 64k;     //用于读响应体的缓冲区数目和大小，默认情况也为分页大小, 网页平均64k以下           proxy_busy_buffers_size 128k;  //用来设置处于busy状态的buffer有多大，默认为proxy_buffers的两倍           proxy_connect_timeout 60;   //和后端服务器连接超时时间           proxy_send_timeout 90;   //向后端服务器发送一次数据包的超时时间           proxy_read_timeout 90;   //定义从后端服务器读取（接收）数据的超时时间           client_max_body_size    10m;    //单次通过nginx上传文件的大小           client_body_buffer_size 128k;    //用户端请求缓冲区的最大字节数           proxy_max_temp_file  1024m      //开启响应缓冲后，临时文件的最大大小, 默认1G           proxy_temp_file_write_size 128k //开启响应缓冲后，每次写数据到临时文件的大小           proxy_temp_path /spool/nginx/proxy_temp 1 2;　　 //缓冲文件位置及命名规则    &#125;&#125;</code></pre></blockquote><p>​        <strong>proxy_busy_buffers_size</strong></p><blockquote><p>配置项<code>proxy_busy_buffers_size</code> 用来设置处于busy状态的buffer有多大，默认为proxy_buffers的两倍。这个参数的作用是限制处于busy（开启响应缓存的情况下，读满数据的缓存响应客户端的过程不能被打断）状态的buffer大小，下述两条配置  {<code>proxy_buffers 4 64k;</code>    <code>proxy_busy_buffers_size 128k;</code>}  便是当用掉两个缓存区（2*64k=128k）的大小后，后面的缓存即使读到数据但不响应给客户端，若读满剩余缓存还不能读完后端服务器响应，则会写到临时文件中。</p></blockquote><p>其他指令：</p><p>​       <strong>proxy_redirect</strong></p><blockquote><p><em>Context: http,server, location</em></p><p>设置后端服务器“Location”响应头和“Refresh”响应头的替换文本。 假设后端服务器返回的响应头是 “Location: <a href="http://localhost:8000/two/some/uri/%E2%80%9D%EF%BC%8C%E9%82%A3%E4%B9%88%E6%8C%87%E4%BB%A4">http://localhost:8000/two/some/uri/”，那么指令</a></p><pre><code>proxy_redirect http://localhost:8000/two/ http://frontend/one/;</code></pre><p>会被重写为  “<code>Location: http://frontend/one/some/uri/</code>”.</p><p>以下指令<code>replacement</code>字符串将省略服务器名</p><pre><code>proxy_redirect http://localhost:8000/two/ /;</code></pre><p>此时将使用代理服务器的主域名和端口号来替换。如果端口是80，可以不加。</p><p>默认的参数<code>default</code>替换使用了location和proxy_pass指令的参数，使用以下两种配置是等价的:</p><pre><code>location /one/ &#123;    proxy_pass     http://upstream:port/two/;    proxy_redirect default;</code></pre><pre><code>location /one/ &#123;    proxy_pass     http://upstream:port/two/;    proxy_redirect http://upstream:port/two/ /one/;</code></pre><p>如果proxy_pass包含变量，则不能使用<code>default</code> ，但是proxy_redirect中可以使用变量，如下：</p><pre><code>proxy_redirect http://localhost:8000/ http://$host:$server_port/;proxy_redirect http://$proxy_host:8000/ /;</code></pre><p>在1.11及以后的版本里，可以使用正则匹配，’’<del>“ 大小写敏感 ，”</del>*” 不区分大小写开始匹配。</p><pre><code>proxy_redirect ~^(http://[^:]+):\d+(/.+)$ $1$2;proxy_redirect ~*/user/([^/]+)/(.+)$      http://$1.example.com/$2;</code></pre><p>可以定义多条</p><pre><code>proxy_redirect default;proxy_redirect http://localhost:8000/  /;proxy_redirect http://www.example.com/ /;</code></pre><p>如果多条指令可以应用到代理服务器的响应头中，只有第一个匹配的被选择。</p><p>使用以下指令，也可以将主机名添加到代理服务器发出的相对重定向：</p><pre><code>proxy_redirect / /;</code></pre></blockquote><p>​       <strong>proxy_next_upstream</strong></p><blockquote><p>当你使用Nginx proxy代理时，如果是代理到后端是使用upstream，那么这个指令就是指定在何种情况下，一个失败的请求应该被发送到下一台后端服务器。</p><p>error – 和后端服务器建立连接时，或向后端服务器发送请求时，或从后端服务器读取响应时，出现错误；</p><p>timeout – 和后端服务器建立连接时，或向后端服务器发送请求时，或从后端服务器读取响应时，出现超时；</p><p>invalid_header – 后端服务器返回空响应或者非法响应头；</p><p>http_500 – 后端服务器返回的响应状态码为500；</p><p>http_502 – 后端服务器返回的响应状态码为502；</p><p>http_503 – 后端服务器返回的响应状态码为503；</p><p>http_504 – 后端服务器返回的响应状态码为504；</p><p>http_404 – 后端服务器返回的响应状态码为404；</p><p>http_403 – 后端服务器返回的响应状态码为403；</p><p>http_429 – 后端服务器返回的响应状态码为429；(1.11.13)</p><p>non_idempotent–通常，如果请求已发送到上游服务器（1.9.13），则使用非幂等方法(POST、LOCK、PATCH)的请求不会传递给下一个服务器；启用此选项显式允许重试此类请求；</p><p>off – 关闭proxy_next_upstream功能—出错就选择另一台上游服务器再次转发。</p><p>只有在没有向客户端发送任何请求的情况下，才有可能将请求传递给下一个服务器。 也就是说，如果在传输响应的过程中发生错误或超时，那么修复这个错误是不可能的。</p><p>将请求传递给下一个服务器可以受到尝试次数和时间的限制，默认均为0， 即失败满足条件立即重试，以下为指令定义 （1.7.5）</p><table><thead><tr><th align="left">Syntax:</th><th><code>proxy_next_upstream_timeout time;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td><code>proxy_next_upstream_timeout 0;</code></td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><hr><table><thead><tr><th align="left">Syntax:</th><th><code>proxy_next_upstream_tries number;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td><code>proxy_next_upstream_tries 0;</code></td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table></blockquote><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><p>负载均衡，英文名称为Load Balance，其含义就是指将互联网或内网的流量（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如FTP服务器、Web服务器、企业核心应用服务器和其它主要任务服务器等，从而协同完成工作任务。</p></blockquote><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><blockquote><p>负载均衡构建在原有网络结构之上，它提供了一种透明且廉价有效的方法扩展服务器和网络设备的带宽、加强网络数据处理能力、增加吞吐量、提高网络的可用性和灵活性。它可以通过流量分发，隐藏实际服务端口，消除服务的单点故障，达到提高应用系统可用性，增强安全性，提升可靠性的要求</p></blockquote><h3 id="NGINX负载均衡"><a href="#NGINX负载均衡" class="headerlink" title="NGINX负载均衡"></a>NGINX负载均衡</h3><h4 id="基本配置-1"><a href="#基本配置-1" class="headerlink" title="基本配置"></a>基本配置</h4><p>默认情况下，使用加权轮询平衡方法在服务器之间分配请求。 在下面的示例中，每7个请求将被分发如下：5个请求转到backend1.example.com，一个请求发送到第二和第三个服务器中的每个服务器。 如果在与服务器通信期间发生错误，请求将被传递到下一个服务器，以此类推，直到所有功能服务器都被尝试为止。 如果无法从任何服务器获得成功的响应，客户端将收到与最后一台服务器通信的结果。</p><blockquote><pre><code>upstream backend &#123;    server backend1.example.com       weight=5;    server backend2.example.com:8080;    server unix:/tmp/backend3;    server backup1.example.com:8080   backup;    server backup2.example.com:8080   backup;&#125;server &#123;    location / &#123;        proxy_pass http://backend;    &#125;&#125;</code></pre></blockquote><blockquote><p>关于 <code>server unix:/tmp/backend3;</code> “unix：”前缀之后指定的UNIX域套接字路径</p><p>Unix domain socket也叫 IPC socket (inter-process communication socket)，即进程间通信 socket，主要用于同一主机上的进程间通信。与主机间的进程通信不同，它不是通过 “IP地址 + TCP或UDP端口号” 的方式进程通信，而是使用 socket 类型的文件来完成通信。</p></blockquote><h5 id="SERVER配置项"><a href="#SERVER配置项" class="headerlink" title="SERVER配置项"></a>SERVER配置项</h5><p>SERVER指定了一台上游服务器的名字，这个名字可以是域名、IP地址端口、UNIX句柄等，在其后还可以跟下列参数:</p><blockquote><ul><li><p><strong>weight=number</strong>：</p><p>​    设置向这台上游服务器转发的权重，默认为1。</p></li><li><p><strong>max_fails=number</strong>：</p><p>​    该选项与fail_timeout配合使用，指在fail_timeout时间段内，如果向当前的上游服务器转 发失败次数超过number，则认为在当前的fail_timeout时间段内这台上游服务器不可用。max_fails默认为1，如果设置为0，则表示 不检查失败次数。</p></li><li><p><strong>fail_timeout=time：fail_timeout</strong></p><p>​    表示该时间段内转发失败多少次后就认为上游服务器暂时不可用，用于优化反向代理功能。它与向上游服务器建立连接的超时时间、读取上游服务器的响应超时时间等完全无关。fail_timeout默认为10秒。</p></li><li><p><strong>down</strong>：</p><p>​    表示所在的上游服务器永久下线，只在使用ip_hash配置项时才有用。</p></li><li><p><strong>backup</strong>：</p><p>​    在使用ip_hash配置项时它是无效的。它表示所在的上游服务器只是备份服务器，只有在所有的非备份上游服务器都失效后，才会向所在的上游服务器转发请求。</p></li></ul></blockquote><h5 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h5><blockquote><table><thead><tr><th align="left">Syntax:</th><th><code>keepalive connections;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td><code>upstream</code></td></tr></tbody></table><p>This directive appeared in version 1.1.4.</p><p>连接参数设置到上游服务器的空闲keepalive连接的最大数量，这些连接保存在每个工作进程的缓存中。 当超过此数字时，关闭最近使用最少的连接。</p><p>应该特别注意的是，keepalive指令没有限制nginx工作进程可以打开的连接到上游服务器的总数。 连接参数应该设置为足够小的数字，以便上游服务器处理新的传入连接。</p><p>当使用默认轮询方法以外的负载平衡方法时，必须在keepalive指令之前激活它们。</p><p>对于HTTP，proxy_http_version指令应该设置为“1.1”，并且应该清除“连接”头字段：</p><pre><code>upstream http_backend &#123;    server 127.0.0.1:8080;    keepalive 16;&#125;server &#123;    ...    location /http/ &#123;        proxy_pass http://http_backend;        proxy_http_version 1.1;        proxy_set_header Connection &quot;&quot;;        ...    &#125;&#125;</code></pre><p>或者，HTTP/1.0持久连接可以通过将“Connection：Keep-Alive”头字段传递给上游服务器来使用，尽管不推荐使用此方法。</p><p>对于FastCGI服务器，需要为保持连接设置fastcgi_keep_conn以工作：</p><pre><code>upstream fastcgi_backend &#123;    server 127.0.0.1:9000;    keepalive 8;&#125;server &#123;    ...    location /fastcgi/ &#123;        fastcgi_pass fastcgi_backend;        fastcgi_keep_conn on;        ...    &#125;&#125;</code></pre><p>SCGI和uwsgi协议没有保持连接的概念。</p></blockquote><h5 id="keepalive-requests"><a href="#keepalive-requests" class="headerlink" title="keepalive_requests"></a>keepalive_requests</h5><blockquote><table><thead><tr><th align="left">Syntax:</th><th><code>keepalive_requests number;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td><code>keepalive_requests 100;</code></td></tr><tr><td align="left">Context:</td><td><code>upstream</code></td></tr></tbody></table><p>This directive appeared in version 1.15.3.</p><p>设置可以通过一个保持连接服务的请求的最大数量。 请求的最大数量后，连接关闭。<br>定期关闭连接是必要的，以释放每个连接内存分配。 因此，使用过高的最大请求数可能导致内存使用过多，不推荐使用。</p></blockquote><h5 id="keepalive-timeout"><a href="#keepalive-timeout" class="headerlink" title="keepalive_timeout"></a>keepalive_timeout</h5><blockquote><table><thead><tr><th align="left">Syntax:</th><th><code>keepalive_timeout timeout;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td><code>keepalive_timeout 60s;</code></td></tr><tr><td align="left">Context:</td><td><code>upstream</code></td></tr></tbody></table><p>This directive appeared in version 1.15.3.</p><p>设置一个到上游服务器的空闲保持连接超时时间。</p></blockquote><h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><h5 id="1、轮询（默认）"><a href="#1、轮询（默认）" class="headerlink" title="1、轮询（默认）"></a>1、轮询（默认）</h5><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><blockquote><p>upstream myapp1 {<br>        server srv1.example.com;<br>        server srv2.example.com;<br>        server srv3.example.com;<br>}</p></blockquote><h5 id="2、weight"><a href="#2、weight" class="headerlink" title="2、weight"></a>2、weight</h5><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</p><blockquote><p>upstream myapp1 {<br>        server srv1.example.com weight=3;<br>        server srv2.example.com weight=2;<br>        server srv3.example.com weight=2;<br>    }</p></blockquote><h5 id="3、least-conn"><a href="#3、least-conn" class="headerlink" title="3、least_conn"></a>3、least_conn</h5><p>指定组应该使用负载均衡方法，其中将请求传递给活动连接数量最少的服务器，同时考虑到服务器的权重。 如果有几个这样的服务器，则使用加权循环平衡方法依次尝试。</p><blockquote><p>upstream myapp1 {<br>    least_conn;<br>    server srv1.example.com;<br>    server srv2.example.com;<br>    server srv3.example.com;<br>}</p></blockquote><h5 id="4、ip-hash"><a href="#4、ip-hash" class="headerlink" title="4、ip_hash"></a>4、ip_hash</h5><p>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题<br>如果其中一个服务器需要暂时移除，则应该用向下参数标记，以保持客户端IP地址的当前散列。</p><blockquote><p>upstream myapp1 {<br>        ip_hash;<br>        server srv1.example.com;<br>        server srv2.example.com  down;<br>        server srv3.example.com;<br>    }</p></blockquote><h5 id="5、hash-key-consistent"><a href="#5、hash-key-consistent" class="headerlink" title="5、hash key [consistent]"></a>5、<strong>hash</strong> key [<code>consistent</code>]</h5><p>  客户机-服务器映射基于散列键值。 键可以包含文本，变量及其组合。 请注意，从组中添加或删除服务器可能会导致将大多数键重映射到不同的服务器。 该方法与缓存：Memcached Perl库兼容。如果指定了一致参数，则将使用ketama一致性散列方法。 该方法确保当一个服务器被添加到或从组中删除时，只有少数密钥将被重新映射到不同的服务器。 这有助于为缓存服务器实现更高的缓存命中率。 该方法与缓存：Memcached：：Fast Perl库兼容，ketama_points参数设置为160。</p><blockquote><p>upstream myapp1 {<br>        hash $request_uri;<br>        server srv1.example.com;<br>        server srv2.example.com;<br>        server srv3.example.com;<br>    }</p></blockquote><h5 id="6、fair（第三方）"><a href="#6、fair（第三方）" class="headerlink" title="6、fair（第三方）"></a>6、fair（第三方）</h5><p>​    按后端服务器的响应时间来分配请求，响应时间短的优先分配。 需要安装fair模块</p><blockquote><p>​    upstream myapp1 {<br>​        fair;<br>​        server srv1.example.com;<br>​        server srv2.example.com;<br>​        server srv3.example.com;<br>​    }</p></blockquote><p>​    ……………………………………………………………………………………………………………………………</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NGINX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGINX的web服务</title>
      <link href="articles/2020/2218122711.html"/>
      <url>articles/2020/2218122711.html</url>
      
        <content type="html"><![CDATA[<h1 id="nginx的web服务"><a href="#nginx的web服务" class="headerlink" title="nginx的web服务"></a>nginx的web服务</h1><p>nginx这款优秀的web服务器，作为后起之秀，在日益拉近与服务器老大哥Apathe的距离，自然有启独特之处，所以值得认真学习一下。本文是一次自己学习nginx的课程记录，课程来源：<a href="https://www.bilibili.com/video/BV1fr4y1c7Gz">baism</a> </p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h4 id="默认网站"><a href="#默认网站" class="headerlink" title="默认网站"></a><strong>默认网站</strong></h4><p>如果nginx只有一个server，这个server就是默认的网站，会默认访问index.html， 以下为初始的默认网站</p><pre><code>server &#123;    listen       80;    server_name  localhost;    location / &#123;        root   html;        index  index.html index.htm;    &#125;    error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;        root   html;    &#125;&#125;</code></pre><h4 id="目录浏览"><a href="#目录浏览" class="headerlink" title="目录浏览"></a><strong>目录浏览</strong></h4><p>显示服务器根目录的目录列表，需要删除默认的index.html文件</p><pre><code>server &#123;    listen       80;    server_name  localhost;    location / &#123;        autoindex on;  //开启目录浏览        autoindex_exact_size off;  //关闭确切大小，便于人眼识别。默认为bytes.        autoindex_localtime on;   //显示文件的服务器时间    &#125;    error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;        root   html;    &#125;&#125;</code></pre><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a><strong>访问控制</strong></h4><p>见文知意，访问控制就是对访问者进行限制，以下根据具体IP控制访问</p><pre class=" language-config"><code class="language-config">#只允许本机访问a目录，其他返回百度location /a &#123;    autoindex on;    allow 127.0.0.1;    deny all;    return http://www.biadu.com;&#125;</code></pre><h4 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证"></a><strong>登录验证</strong></h4><p>需要输入用户及密码才能访问，可以使用htpasswd或openssl等生成用户密码</p><ol><li><p>安装htpasswod工具，在http-tools包下</p><pre class=" language-shell"><code class="language-shell">yum -y install httpd-tools</code></pre></li><li><p>生成用户密码</p><pre class=" language-shell"><code class="language-shell">mkdir /usr/local/nginx/passwdhtpasswd -c /usr/local/nginx/passwd/htpasswd username</code></pre></li></ol><ol start="3"><li><p>配置pass目录的验证需要登录</p><p>设置登录后的显示信息</p><pre class=" language-shell"><code class="language-shell">echo "Welcome to login" > index.html</code></pre><p>配置文件</p><pre><code>location /pass &#123;    auth_basic &quot;Login verification&quot;;    auth_basic_user_file /usr/local/nginx/passwd/htpasswd;&#125;</code></pre></li></ol><h4 id="防止盗链"><a href="#防止盗链" class="headerlink" title="防止盗链"></a><strong>防止盗链</strong></h4><p>防盗链功能基于HTTP协议支持的Referer机制，通过Referer跟踪来源，对来源进行识别和判断。</p><pre><code>location ~* \.(png|gif|bmp)$ &#123;alias /data/images/;    valid_referers none blocked *.images.com;    if ($invalid_referer) &#123;       return 403;    &#125;&#125;</code></pre><h4 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h4><ol><li><p>基于IP的虚拟主机 </p><pre><code>server &#123;    listen       192.168.0.20:80;    location / &#123;        root   html/app1;        index  index.html index.htm index.php;    &#125;&#125;server &#123;    listen       192.168.0.21:80;    location / &#123;        root   html/app2;        index  index.html index.htm;    &#125;&#125;</code></pre></li><li><p>基于端口的虚拟主机</p><pre><code>基于端口server &#123;    listen       80;    server_name  www.demo.com;    location / &#123;        root   html/app1;        index  index.html index.htm index.php;    &#125;&#125;server &#123;    listen       8080;    server_name  www.demo.com;    location / &#123;        root   html/app2;        index  index.html index.htm;    &#125;&#125;</code></pre></li><li><p>基于域名的虚拟主机</p><pre><code>server &#123;    listen       80;    server_name  app1.demo.com;    location / &#123;        root   html/app1;        index  index.html index.htm index.php;    &#125;&#125;server &#123;    listen       80;    server_name  app2.demo.com;    location / &#123;        root   html/app2;        index  index.html index.htm;    &#125;&#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NGINX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGINX配置文件</title>
      <link href="articles/2020/2223132411.html"/>
      <url>articles/2020/2223132411.html</url>
      
        <content type="html"><![CDATA[<p>nginx的配置文件大致可以分为三个部分：全局块、EVENTS块、HTTP块，示意图如下</p><img src="https://cdn.jsdelivr.net/gh/noslime/noslime.github.io@master/source/images/nginx.conf.png" alt="nginx.conf.png" style="zoom:80%;" /><h3 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h3><p>从配置文件开始到events块之间的内容，主要会设置一些影响nginx服务器整体运行的配置指令，一般有运行nginx服务器的用户组，nginx进程pid存放路径，错误日志存放路径，允许生成worker process数等。</p><pre class=" language-config"><code class="language-config">#配置worker子进程用户或者组，默认nobody，安全问题，建议用nobody#user  nobody;#worker数和服务器的cpu数相等是最为适宜worker_processes  2;#配置Nginx worker进程最大打开文件数worker_rlimit_nofile 65535;#work绑定cpu(4 work绑定4cpu)worker_cpu_affinity 0001 0010 0100 1000#work绑定cpu (4 work绑定8cpu中的4个) 。worker_cpu_affinity 0000001 00000010 00000100 00001000  #error_log path(存放路径) level(日志等级)path表示日志路径，level表示日志等级，#具体如下：[ debug | info | notice | warn | error | crit ]# 从左至右，日志详细程度逐级递减，即debug最详细，crit最少，默认为crit。 #error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#进程运行文件所在位置#pid        logs/nginx.pid;</code></pre><h3 id="EVENTS块"><a href="#EVENTS块" class="headerlink" title="EVENTS块"></a>EVENTS块</h3><p>此部分涉及的主要是nginx工作模式，包括每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启网络连接序列化等。</p><pre class=" language-config"><code class="language-config">events &#123;    #这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx能建立的最大连接数，应该是                     #Max_client=worker_connections * worker_processes。    #当然，这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的最大并发数量是worker_connections *         #worker_processes，    #如果是支持http1.1的浏览器每次访问要占两个连接，    #所以普通的静态访问最大并发数是： worker_connections * worker_processes /2，    #而如果是HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes/4。    #因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。    worker_connections  1024;      #Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。         #其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式    #这个值是表示nginx要支持哪种多路io复用。    #一般的Linux选择epoll, 如果是(*BSD)系列的Linux使用kquene。    #windows版本的nginx不支持多路IO复用，这个值不用配。    use epoll;    #当一个worker抢占到一个链接时，是否尽可能的让其获得更多的连接,默认是off 。    multi_accept on;    #设置网路连接序列化，防止惊群现象发生，默认为on，这是一种保守的设置    #但是如果你的网站访问量比较大，为了系统的吞吐量，我还是建议大家关闭它。    accept_mutex  on;&#125;</code></pre><h3 id="HTTP-块"><a href="#HTTP-块" class="headerlink" title="HTTP 块"></a>HTTP 块</h3><p>这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括 http全局块、[upstream] 、server 块。</p><h4 id="HTTP全局块"><a href="#HTTP全局块" class="headerlink" title="HTTP全局块"></a>HTTP全局块</h4><p>http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</p><p>以下给出一些参数设置，为了方便描述，全写在了一起。其中很多参数可以设置在http、server、location处，实际应根据具体业务设置位置。 一般来说，设置的位置越在内层，优先级越高。 详见nginx <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html">官方文档</a></p><pre class=" language-config"><code class="language-config">http &#123;    #当web服务器收到静态的资源文件请求时，依据请求文件的后缀名在服务器的MIME配置文件中    #找到对应的MIME Type，再根据MIME Type设置HTTP Response的Content-Type，然后浏览器    #根据Content-Type的值处理文件。    include       mime.types;    #如果 不能从mime.types找到映射的话，用以下作为默认值    default_type  application/octet-stream;    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.    server_names_hash_bucket_size 128;    ###################################HTTP请求####################################    #一个请求完成之后还要保持连接多久    keepalive_timeout  5;    #设定通过nginx上传文件的大小    client_max_body_size 300m;    #请求体缓存大小    client_body_buffer_size 64k;    #临时文件位置    #小于client_body_buffer_size直接在内存中高效存储。如果大于client_body_buffer_size小于client_max_body_size会存储临时文件，临时文件位于client_body_temp下，一定要有权限。    client_body_temp_path  /spool/nginx/client_body_temp 3 2;    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。    client_header_buffer_size 4k;    #读取大型客户端请求头的缓冲区的最大数量和大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取    large_client_header_buffers 8 128k;    #########################################################################     ###################################日志####################################     #访问日志位置  server、location中若有日志配置，优先级更高     access_log  logs/host.access.log  main;     access_log  logs/host.access.404.log  log404;     #日志格式化     log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '     '$status $body_bytes_sent "$http_referer" '     '"$http_user_agent" "$http_x_forwarded_for"';     #########################################################################    #################################高效文件传输######################################    #此配置项用来在两个文件描述符之间直接传递数据(完全在内核中操作)，从而避免了数据在内核         #缓冲区和用户缓冲区之间的拷贝，操作效率很高，被称之为零拷贝，适用于有大文件上传下载的情况         #如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统负载    #可以在http块，server块，location块。    sendfile  on;    #此选项允许或禁止使用sock的TCP_CORK的选项，此选项仅在使用sendfile的时候使用    #用户层可通过setsockopt系统调用设置TCP套接口的TCP_CORK选项。开启时，内核将阻塞不完整的报文，当关闭此选项时，发送阻塞的报文。此处的不完整指的是应用层发送的数据长度不足一个MSS长度。使用场景是在调用sendfile发送文件内容之前，提前发送一个描述文件信息的头部数据段，并且阻塞住此头部数据，与之后的sendfile数据一同发送。或者用于优化吞吐性能。但是，TCP_CORK最多只能将数据阻塞200毫秒，如果超过此时间值，内核将自动发送阻塞的数据       tcp_nopush on;       #tcp_nodelay off 会增加通信的延时，但是会提高带宽利用率。适用于在高延时、数据量大的通信场景    #tcp_nodelay on 会增加小包的数量，但是可以提高响应速度。适用于及时性高的通信场景    #tcp_nodelay与tcp_nopush是互斥的    tcp_nodelay off;    #########################################################################    #################################gzip###################################    #开启或者关闭gzip模块    #gzip  on ;    #设置允许压缩的页面最小字节数，页面字节数从header头中的Content-Length中进行获取。    #gzip_min_lenth 1k;    # gzip压缩比，1 压缩比最小处理速度最快，9 压缩比最大但处理最慢（传输快但比较消耗cpu）    #gzip_comp_level 4;    #匹配MIME类型进行压缩，（无论是否指定）"text/html"类型总是会被压缩的。    #gzip_types types text/plain text/css application/json  application/x-javascript text/xml      #########################################################################    ##############################文件缓存###########################################    #动静分离  指定缓存启用    #服务器端静态资源缓存，最大缓存到内存中的文件数，非活动的（没要求到的文件）会在20秒后从缓存中释放    open_file_cache max=102400 inactive=20s;       #活跃期限内最少使用的次数，否则视为不活跃。    open_file_cache_min_uses 2;    #验证缓存是否活跃的时间间隔    open_file_cache_valid 30s;    #文件错误是否缓存    open_file_cache_errors on    #########################################################################    #################################代理服务器###################################    #后端服务器连接的超时时间_发起握手等候响应超时时间    proxy_connect_timeout 90;    #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）    proxy_read_timeout 180;    #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据    proxy_send_timeout 180;    #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小    proxy_buffer_size 256k;    #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k    proxy_buffers 4 256k;    #proxy_busy_buffers_size不是独立的空间，他是proxy_buffers和proxy_buffer_size的一部分。nginx会在没有完全读完后端响应就开始向客户端传送数据，所以它会划出一部分busy状态的buffer来专门向客户端传送数据(建议为proxy_buffers中单个缓冲区的2倍)，然后它继续从后端取数据。proxy_busy_buffer_size参数用来设置处于busy状态的buffer有多大。1）如果完整数据大小小于busy_buffer大小，当数据传输完成后，马上传给客户端；2）如果完整数据大小不小于busy_buffer大小，则装满busy_buffer后，马上传给客户端；    proxy_busy_buffers_size 256k;    #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长    proxy_temp_file_write_size 256k;    #设置内存缓存空间大小为200MB，1天没有被访问的内容自动清除，硬盘缓存空间大小为30GB。    proxy_cache_path /data/proxy_cache_dir levels=1:2 keys_zone=cache_one:200m inactive=1d max_size=30g;    #表示使nginx阻止HTTP应答代码为300或者更高的应答    proxy_intercept_errors on;    #######################################################################################        upstream streamname&#123;...&#125;    server &#123;...&#125;&#125;</code></pre><ol><li><p>访问日志格式化参数说明</p><p>注：log_format可设为json格式以方便后续分析处理</p></li></ol><blockquote><p>​    #$http_x_forwarded_for 用以记录客户端的ip地址；</p><p>​    #$remote_addr  上一级代理的IP地址；</p><p>​    #$remote_user：用来记录客户端用户名称；<br>​    #$time_local： 用来记录访问时间与时区；<br>​    #$request： 用来记录请求的url与http协议；<br>​    #$status： 用来记录请求状态；成功是200，<br>​    #$body_bytes_sent ：记录发送给客户端文件主体内容大小；<br>​    #$http_referer：用来记录从那个页面链接访问过来的；<br>​    #$http_user_agent：记录客户浏览器的相关信息；</p><p>如下生成一种json格式的日志</p><pre><code>log_format main_json &#39;&#123;&quot;@timestamp&quot;:&quot;$time_local&quot;,&#39;&#39;&quot;client_ip&quot;: &quot;$remote_addr&quot;,&#39;&#39;&quot;request&quot;: &quot;$request&quot;,&#39;&#39;&quot;status&quot;: &quot;$status&quot;,&#39;&#39;&quot;bytes&quot;: &quot;$body_bytes_sent&quot;,&#39;&#39;&quot;x_forwarded&quot;: &quot;$http_x_forwarded_for&quot;,&#39;&#39;&quot;referer&quot;: &quot;$http_referer&quot;&#39;&#39;&#125;&#39;;access_log logs/access_json.log main_json;</code></pre></blockquote><ol start="2"><li>临时文件存储位置     </li></ol><blockquote><p>Syntax: client_body_temp_path path [level1 [level2 [level3]]]; </p><p>Default:    client_body_temp_path client_body_temp; </p><p>Context:    http, server, location</p><p>client_body_temp_path  /spool/nginx/client_body_temp 3 2 1;     //3 2 1代表目录名称长度</p><p>以上设置可能产生缓存文件格式：/spool/nginx/client_temp/456/78/9/20201127</p><p>chown -R username:usergroup /spool/nginx/client_body_temp  //为防止权限问题，可为文件设置所有者</p></blockquote><ol start="3"><li>文件引入</li></ol><blockquote><p>​    若server较多，为保持配置文件结构清晰，可以每个虚拟主机另起一个配置文件，如：<br>​    include /etc/nginx/conf.d/*.conf;  //配置在http全局块</p></blockquote><h4 id="Upstream"><a href="#Upstream" class="headerlink" title="Upstream"></a>Upstream</h4><p>upstream是nginx的HTTP Upstream模块，此模块不是必须的，这个模块通过一个指定的调度算法来实现客户端IP到后端服务器的负载均衡。</p><p>upstream中服务器的常见参数</p><blockquote><p>weight<code>=</code><em>number</em>   设置服务器的权重，默认为1</p><p>max_conns=number  限制到代理服务器的最大同时连接数，默认为0</p><p>fail_timeout=time     服务器不可用的时间 默认为10秒</p><p>max_fails=number   设置在fail_timeout参数设置的持续时间内与服务器通信的失败尝试次数</p><p>backup    备用服务器，主服务器不可用时启用，不能和hash和random负载平衡方法一起使用</p><p>down  标记服务器永久不可用</p></blockquote><pre class=" language-config"><code class="language-config">http &#123;    ...    # 1、轮询（默认）    # 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。     upstream myapp1 &#123;        server srv1.example.com;        server srv2.example.com;        server srv3.example.com;    &#125;    # 2、最小连接负载均衡    # nginx将尝试不使用存在过多的请求的应用服务器，而是将新请求分发到不太繁忙的服务器    upstream myapp1 &#123;        least_conn;        server srv1.example.com;        server srv2.example.com;        server srv3.example.com;    &#125;    # 3、指定权重    # 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。    upstream myapp1 &#123;        server srv1.example.com weight=3;        server srv2.example.com weight=2;        server srv3.example.com weight=2;    &#125;    #4、IP绑定 ip_hash    # 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。    upstream myapp1 &#123;        ip_hash;        server srv1.example.com;        server srv2.example.com;        server srv3.example.com;    &#125;    #5、备机方式 backup    # 正常情况不访问设定为backup的备机，只有当所有非备机全都宕机的情况下，服务才会进备机。    # backup 不能和ip_hash一起使用    upstream myapp1 &#123;        server srv1.example.com;        server srv2.example.com;        server srv3.example.com backup;    &#125;    #6、fair（第三方）    #按后端服务器的响应时间来分配请求，响应时间短的优先分配。 需要安装fair模块    upstream myapp1 &#123;        fair;        server srv1.example.com;        server srv2.example.com;        server srv3.example.com;    &#125;    #7、url_hash（第三方） 需要安装url_hash模块    #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。    upstream myapp1 &#123;        server srv1.example.com;        server srv2.example.com;        server srv3.example.com;        hash $request_uri    &#125;      server &#123;        listen 80;        location / &#123;            proxy_pass http://myapp1;      &#125;&#125;</code></pre><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>server块：配置虚拟主机的相关参数，一个http中可以有多个server。而server块又包含多个<strong>location块</strong></p><p>location块：配置请求的路由，以及各种页面的处理情况。</p><pre class=" language-config"><code class="language-config">http &#123;    ...    upstream myserver&#123;&#125;    server &#123;        #监听端口号        listen       80;        #服务名        server_name  192.168.161.130;        #字符集        #charset utf-8;    #location [=|~|~*|^~] /uri/ &#123; … &#125;       # = 精确匹配    # ~ 正则匹配，区分大小写    # ~* 正则匹配，不区分大小写    # ^~  关闭正则匹配    #匹配原则：    # 1、所有匹配分两个阶段，第一个叫普通匹配，第二个叫正则匹配。    # 2、普通匹配，首先通过“=”来匹配完全精确的location        # 2.1、 如果没有精确匹配到， 那么按照最大前缀匹配的原则，来匹配location        # 2.2、 如果匹配到的location有^~,则以此location为匹配最终结果，如果没有那么会把匹配的结果暂存，继续进行正则匹配。        # 3、正则匹配，依次从上到下匹配前缀是~或~*的location, 一旦匹配成功一次，则立刻以此location为准，不再向下继续进行正则匹配。        # 4、如果正则匹配都不成功，则继续使用之前暂存的普通匹配成功的location.        # 匹配任何查询，因为所有请求都以 / 开头。但是正则表达式规则和长的块规则将被优先和查询匹配。        location / &#123;           #定义服务器的默认网站根目录位置        root   html;        #默认访问首页索引文件的名称        index  index.html index.htm;        #反向代理路径         proxy_pass http://myapp1;        #反向代理的超时时间         proxy_connect_timeout 10;         proxy_redirect default;         &#125;         location  /images/ &#123;                root images ;            deny 127.0.0.1;  #拒绝的ip              allow 172.18.5.54; #允许的ip         &#125;         # 匹配任何以/images/jpg/ 开头的任何查询并且停止搜索。任何正则表达式将不会被测试。          location ^~ /images/jpg/ &#123;              root images/jpg/ ;         &#125;         location ~*.(gif|jpg|jpeg)$ &#123;           #所有静态文件直接读取硬盘              root pic ;          #expires定义用户浏览器缓存的时间为3天，如果静态页面不常更新，可以设置更长，          #这样可以节省带宽和缓解服务器的压力              expires 3d; #缓存3天         &#125;        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NGINX </tag>
            
            <tag> CONFIG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGINX简介及安装</title>
      <link href="articles/2020/2242062311.html"/>
      <url>articles/2020/2242062311.html</url>
      
        <content type="html"><![CDATA[<p>nginx这款优秀的反向代理服务器，在网站的运行中占的比例越来越高，不管工作中是否用到，都值得去学习一下，一个好的开头必不可少，本文记录一下nginx的安装。</p><h3 id="一、nginx概述"><a href="#一、nginx概述" class="headerlink" title="一、nginx概述"></a>一、nginx概述</h3><p><em>Nginx</em> (engine x) 是一个高性能的<a href="https://baike.baidu.com/item/HTTP">HTTP</a>和<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>web服务器，同时也提供了IMAP/POP3/SMTP服务，nginx能够达到50000次并发，性能优异，且占用内存较小。国内大型的站点，例如百度、京东、新浪、网易、腾讯、淘宝等，都使用了<a href="http://nginx.org/">nginx</a> .</p><h3 id="二、常用功能"><a href="#二、常用功能" class="headerlink" title="二、常用功能"></a>二、常用功能</h3><ol><li><p>反向代理</p><ul><li> 正向代理：局域网中的客户端(如浏览器)访问Internet，通过配置代理访问，这种代理用户访问网站代理就是正向代理。</li><li> 反向代理：向代理服务器发送请求，反向代理转发到实际服务器，客户端不需要做任何配置。目标服务器对客户端是透明的。</li></ul></li><li><p>负载均衡</p><p>nginx服务器收到请求后，分发到不同的服务器上去处理，提高系统负载的过程，也就是我们所说的负载均衡。</p></li><li><p>Web缓存</p><p>Nginx可以对不同的文件做不同的缓存处理，配置灵活，并且支持FastCGI_Cache，主要用于对FastCGI的动态程序进行缓存。配合着第三方的ngx_cache_purge，对制定的URL缓存内容可以的进行增删管理</p></li></ol><h3 id="三、nginx安装"><a href="#三、nginx安装" class="headerlink" title="三、nginx安装"></a>三、nginx安装</h3><h4 id="YUM安装"><a href="#YUM安装" class="headerlink" title="YUM安装"></a>YUM安装</h4><ol><li>安装先决条件：</li></ol><blockquote><pre><code>sudo yum install yum-utils</code></pre></blockquote><ol start="2"><li>若要设置 yum 存储库，请创建具有以下内容命名的文件：<code>/etc/yum.repos.d/nginx.repo</code></li></ol><blockquote><pre class=" language-shell"><code class="language-shell">[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true[nginx-mainline]name=nginx mainline repobaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck=1enabled=0gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true</code></pre></blockquote><ol start="3"><li>默认情况下，使用稳定 nginx 包的存储库。如果要使用主线 nginx 包，请运行以下命令：</li></ol><blockquote><pre class=" language-shell"><code class="language-shell">sudo yum-config-manager --enable nginx-mainline</code></pre></blockquote><ol start="4"><li>要安装 nginx，请运行以下命令：</li></ol><blockquote><pre class=" language-shell"><code class="language-shell">sudo yum install nginx</code></pre></blockquote><ol start="5"><li><p>当提示接受 GPG 密钥时，请验证指纹是否匹配，如果匹配，请接受它。</p><p><code>573B FD6B 3D8F BC64 1079 A6AB ABF5 BD82 7BD9 BF62</code></p></li><li><p>命令手册 例：/usr/bin/nginx -v 查看版本情况</p></li></ol><blockquote><pre class=" language-shell"><code class="language-shell">-?,-h         : this help-v            : show version and exit-V            : show version and configure options then exit-t            : test configuration and exit-T            : test configuration, dump it and exit-q            : suppress non-error messages during configuration testing-s signal     : send signal to a master process: stop, quit, reopen, reload-p prefix     : set prefix path (default: NONE)-c filename   : set configuration file (default: conf/nginx.conf)-g directives : set global directives out of configuration file</code></pre></blockquote><ol start="7"><li>YUM安装默认位置：</li></ol><blockquote><pre class=" language-shell"><code class="language-shell">/usr/sbin/nginx   //执行程序位置/etc/nginx/  // nginx.conf所在/usr/share/nginx  //静态文件/var/log/nginx/  //访问记录日志 错误日志/var/run/nginx.pid   //进程ID文件</code></pre></blockquote><h4 id="从源包手动编译安装"><a href="#从源包手动编译安装" class="headerlink" title="从源包手动编译安装"></a>从源包手动编译安装</h4><ol><li><p>安装所需依赖</p><ul><li><p>gcc是编程语言编译器，支持c、c++等，而nginx是由C语言编写而成，所以手动安装的编译过程要依赖gcc编译器。</p></li><li><p>pcre库是一组函数，它们使用与 Perl 5 相同的语法和语义实现正则表达式模式匹配，nginx的请求分发需要用到正则匹配。 其中devel代表供开发使用，包括头文件链接库等， 如果安装基于pcre开发的程序，只需要安装pcre包就行了，但编译使用了PCRE库的源代码，则需要pcre-devel。</p></li><li><p>zlib 是通用的压缩库，nginx的压缩模块需要用到，主要对网络传输的资源进行压缩以提高传输效率。</p></li><li><p>nginx涉及到很多加密、解密的功能。如https中需要用到加密解密，所以编译的时候需要使用openssl</p></li></ul></li></ol><blockquote><pre class=" language-shell"><code class="language-shell">yum install -y gcc pcre-devel zlib-devel openssl-devel  //解决依赖问题</code></pre></blockquote><ol start="2"><li>下载并解压nginx程序包</li></ol><blockquote><pre class=" language-shell"><code class="language-shell">wget -P /usr/src https://nginx.org/download/nginx-1.18.0.tar.gztar zxvf nginx-1.18.0.tar.gz</code></pre></blockquote><ol start="3"><li><p>进入解压文件夹构建程序</p><p>configure命令作用是分析程序建立环境，检查是否安装了必要的外部工具和组件，</p><p>并创建配置文件makefile，此文件描述了包括最终完成的程序各组件之间的关系和依赖性<br>configure命令有多个可选项，如下所用的–prefix是告诉程序的安装位置<br>如不指定 则./configure –help里面有个path，就是默认安装路径<br>关于nginx的configure更多选项设置 详见 <a href="http://nginx.org/en/docs/configure.html">Configure</a></p></li></ol><blockquote><pre class=" language-shell"><code class="language-shell">cd nginx-1.18.0./configure  --prefix=/usr/local/nginx    </code></pre></blockquote><ol start="4"><li>编译与安装</li></ol><blockquote><pre class=" language-shell"><code class="language-shell">$ make && make install </code></pre></blockquote><ol start="5"><li>常用命令</li></ol><blockquote><pre class=" language-shell"><code class="language-shell">/usr/local/nginx/sbin/nginx    //启动/usr/local/nginx/sbin/nginx -c 具体nginx.conf配置文件路径   //根据指定配置文件启动/usr/local/nginx/sbin/nginx -v //查看版本/usr/local/nginx/sbin/nginx -s stop //停止/usr/local/nginx/sbin/nginx -s reload  //热启动，重新加载配置文件</code></pre></blockquote><ol start="6"><li><p>使用systemctl管理nginx</p><p>创建一个nginx.service文件</p></li></ol><blockquote><pre class=" language-shell"><code class="language-shell">touch /usr/lib/systemd/system/nginx.service</code></pre></blockquote><p>​    编辑文件内容为：</p><blockquote><pre class=" language-shell"><code class="language-shell">[Unit]Description=nginx - high performance web serverDocumentation=http://nginx.org/en/docs/After=network-online.target remote-fs.target nss-lookup.targetWants=network-online.target[Service]Type=forkingPIDFile=/var/run/nginx.pidExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.confExecReload=/bin/sh -c "/bin/kill -s HUP $(/bin/cat /var/run/nginx.pid)"ExecStop=/bin/sh -c "/bin/kill -s TERM $(/bin/cat /var/run/nginx.pid)PrivateTmp=true    //设置是否使用私有的tmp目录[Install]WantedBy=multi-user.target</code></pre></blockquote><p>​    常用命令</p><blockquote><pre class=" language-shell"><code class="language-shell">systemctl start nginxsystemctl stop nginxsystemctl reload nginxsystemctl status nginxsystemctl enable nginx  //设置开机自启systemctl disable nginx  //关闭开机自启</code></pre></blockquote><h3 id="四、开放必要的端口"><a href="#四、开放必要的端口" class="headerlink" title="四、开放必要的端口"></a>四、开放必要的端口</h3><ol><li><p>为nginx开放80端口</p><p> 由于linux默认开启了防火墙，nginx是访问不成功的，如果是个人学习，可以直接关闭防火墙</p></li></ol><blockquote><pre class=" language-shell"><code class="language-shell">systemctl stop firewalld</code></pre></blockquote><p>​        否则只开启指定的端口供外部访问，以下为一些端口操作命令</p><blockquote><pre class=" language-shell"><code class="language-shell">firewall-cmd --zone=public --add-port=80/tcp --permanent   //永久开放80端口firewall-cmd --reload   //重载使之生效firewall-cmd --zone= public --query-port=80/tcp   //查看是否开放firewall-cmd --zone= public --remove-port=80/tcp --permanent   //删除80端口firewall-cmd --zone=public --add-port=40000-45000/tcp --permanent  开放一段端口firewall-cmd --zone=public --list-ports  //查看开放的端口列表</code></pre></blockquote><p>​        若服务器使用的iptables，则：</p><blockquote><pre class=" language-shell"><code class="language-shell">iptables -I INPUT -p tcp --dport 80 -j ACCEPT   //开放80service iptables save  //保存策略service iptables restart  //重启防火墙iptables -D INPUT 2  // 删除规则，通过 iptables -L -n --line-number 可以显示规则和相对应的编号</code></pre></blockquote><h3 id="五、赋予用户权限"><a href="#五、赋予用户权限" class="headerlink" title="五、赋予用户权限"></a>五、赋予用户权限</h3><p>大多情况下并不建议使用root用户去操作数据，因此在使用普通用户时可能会遇到一些权限问题，以下步骤帮助用户获取nginx相关的操作权限。</p><ol><li><p>创建用户组</p><pre class=" language-shell"><code class="language-shell">sudo groupadd nginx</code></pre></li><li><p>将当前用户假如nginx用户组</p><pre class=" language-shell"><code class="language-shell">sudo usermod -g nginx username</code></pre></li><li><p>将nginx的权限给nginx用户组的用户</p><pre class=" language-shell"><code class="language-shell">sudo chown -R username:nginx /usr/local/nginx</code></pre></li><li><p>如有必要，给nginx用户组写权限</p><pre class=" language-shell"><code class="language-shell">sudo chmod g+w -R /usr/local/nginx</code></pre></li><li><p>如有必要，授予nginx目录segid权限，做用户组控制</p><pre class=" language-shell"><code class="language-shell">sudo chmod g+s -R /usr/local/nginx</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NGINX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正确使用SQL既是优化</title>
      <link href="articles/2020/5440082111.html"/>
      <url>articles/2020/5440082111.html</url>
      
        <content type="html"><![CDATA[<h2 id="SQL优化小结"><a href="#SQL优化小结" class="headerlink" title="SQL优化小结"></a>SQL优化小结</h2><h3 id="一、正确使用索引"><a href="#一、正确使用索引" class="headerlink" title="一、正确使用索引"></a>一、正确使用索引</h3><ol><li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by 涉及的列上建立索引</p></li><li><p>应尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><pre class=" language-SQL"><code class="language-SQL">SELECT ID FROM TEST_INDEX WHERE NUM　IS NULL</code></pre><p>可以以在num上设置默认值0，确保表中null列没有null值，然后这样查询：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> ID <span class="token keyword">FROM</span> TEST_INDEX <span class="token keyword">WHERE</span> NUM <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre></li><li><p>应尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</p></li><li><p>应尽量避免在WHERE子句中使用OR来连接条件，否则只有当条件中的列都是索引字段，且等值比较时候，才能使用索引，如：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> ID <span class="token keyword">FROM</span> TEST_INDEX <span class="token keyword">WHERE</span>  NUM<span class="token operator">=</span><span class="token number">10</span> <span class="token operator">OR</span> AGE<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//使用的是index_merge</span><span class="token keyword">SELECT</span> ID <span class="token keyword">FROM</span> TEST_INDEX <span class="token keyword">WHERE</span>  NUM<span class="token operator">&lt;</span><span class="token number">10</span> <span class="token operator">OR</span> AGE<span class="token operator">></span><span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//未使用索引</span></code></pre><p>可以这样查询：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> ID <span class="token keyword">FROM</span> TEST_INDEX <span class="token keyword">WHERE</span> NUM<span class="token operator">=</span><span class="token number">10</span><span class="token keyword">UNION</span> <span class="token keyword">ALL</span><span class="token keyword">SELECT</span> ID <span class="token keyword">FROM</span> TEST_INDEX <span class="token keyword">WHERE</span> NUM<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span></code></pre></li><li><p>对于连续的数值能用BETWEEN就不要用IN，否则也会导致全表扫描，如</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> ID <span class="token keyword">FROM</span> TEST_INDEX <span class="token keyword">WHERE</span> NUM　<span class="token operator">IN</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可以改为：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> ID <span class="token keyword">FROM</span> TEST_INDEX <span class="token keyword">WHERE</span> NUM <span class="token operator">BETWEEN</span> <span class="token number">1</span> <span class="token operator">AND</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre></li></ol><ol start="6"><li><p>应尽量避免在WHERE子句等号的左边进行函数、算术运算或其他表达式运算，这将导致引擎放弃使用索引。如</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> ID <span class="token keyword">FROM</span> TEST_INDEX <span class="token keyword">WHERE</span> SUBSTRING<span class="token punctuation">(</span>NUM<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token string">'sql'</span><span class="token punctuation">;</span></code></pre><p>可以改为：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> ID <span class="token keyword">FROM</span> TEST_INDEX <span class="token keyword">WHERE</span> NUM <span class="token operator">LIKE</span> sql<span class="token operator">%</span><span class="token punctuation">;</span></code></pre><p>在使用like关键字进行查询的时候，如果匹配字符串的第一个字符为”%”索引不会器作用。只有”%”不在第一个位置，索引才会起作用。</p></li><li><p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应让字段顺序与索引顺序相一致</p><blockquote><p>假如对col1、col2、col3创建组合索引，相当于创建了（col1）、（col1，col2）、（col1，col2，col3）3个索引</p></blockquote></li><li><p>并不是所有的列都适合做索引，离散型不高的列，即当一列数据有大量重复数据时不适合做索引，如性别、国家等有限数据列</p></li><li><p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率</p><p>​    </p></li><li><p>IN和EXIST的选择，in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。其中in会使用外层查询表索引，而exist使用内层查询表索引，所以外层查询表小于子查询表，则用exists，外层查询表大于子查询表，则用in，如果外层和子查询表差不多，则爱用哪个用哪个。另外，如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</p></li></ol><hr><h3 id="二、常用SQL操作符"><a href="#二、常用SQL操作符" class="headerlink" title="二、常用SQL操作符"></a>二、常用SQL操作符</h3><ol><li><p>JOIN</p><p>包括LEFT JOIN、INNER JOIN、RIGHT JOIN、FULL JOIN等几种，我找来一张网图简单明了了说明了几个操作符的作用范围及基本使用方法，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/noslime/noslime.github.io@master/source/images/sqljoins.png"></p><p>使用时应以小表驱动大表，左连接LEFT JOIN中，左表为驱动表，右表为被驱动表；右连接RIGHT JOIN中，右表为驱动表，左表为被驱动表。其中应尽量在被驱动表上建立索引。</p></li><li><p>UNION </p><p>UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table_name1<span class="token keyword">UNION</span><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table_name2</code></pre><p>默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</p></li></ol><hr><h3 id="三、表设计"><a href="#三、表设计" class="headerlink" title="三、表设计"></a>三、表设计</h3><ol><li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了</p></li><li><p>对于长度基本固定的列，如果该列恰好更新又特别频繁，适合char。</p></li><li><p>TIMESTAMP和 DATETIME选择</p><blockquote><p>DATETIME和 TIMESTAMP类型所占的存储空间不同，前者8字节，后者4字节。前者范围是 </p><p>1000-01-01-00:00:00 ~ 9999-12-31 23:59:59，后者范围是 1970-01-01 8:00:01 ~ 2038-01-19 </p><p>11:14:07。 所以 TIMESTAMP支持的范围比 DATETIME要小。</p><p>TIMESTAMP显示与时区有关，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。另外TIMESTAMP每个表允许一个自增时间戳，如：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span><span class="token keyword">USER</span><span class="token punctuation">`</span> <span class="token keyword">ADD</span> <span class="token keyword">COLUMN</span> <span class="token punctuation">`</span>UTIME<span class="token punctuation">`</span> <span class="token keyword">TIMESTAMP</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//UTIME字段插入更新数据时不需指定</span></code></pre><p>显然存储空间小且会自动切换的TIMESTAMP更方便一些，虽然表示时间范围小好多，但根据IT行业技术换代的速度，相信不用等到2038年，就已经有了更好的替换方案。</p></blockquote></li><li><p> 所有表都要指定主键，不要强制使用外键。如果没有主键或者唯一索引，update/delete 是通过所有字段来定位操作的行，相当于每行就是一次全表扫描。即使2个表的字段有明确的外键参考关系，也不建议使用 FOREIGN KEY，因为新纪录会去主键表做校验，影响性能。</p></li><li><p>对精度有要求可以用decimal。其中decimal(M,D) M表示总长度，D表示小数部分，M范围是1到65，D范围是0到30。</p><ol><li>float：浮点型，含字节数为4, 32bit，7个有效位</li><li>double：双精度实型，含字节数为8, 64bit，15个有效位</li><li>decimal：数字型，128bit，不存在精度损失，常用于银行账目计算，28个有效位。</li></ol></li><li><p>字段不要过多，取名见名思义，加注释</p><p>字段过多的表可以进行分表，如用户表USER有id、姓名、密码、地址、电话、爱好、备注等字段，可将地址、爱好、备注等不常用字段分解出另一个表USER_DETAIL。</p></li><li><p>对于经常联合查询的表，可根据需要看是否可以建立中间表存储需要联合查询的数据。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="articles/2020/2222141311.html"/>
      <url>articles/2020/2222141311.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
